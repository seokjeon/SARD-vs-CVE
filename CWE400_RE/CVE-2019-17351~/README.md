# ğŸ“ CVE-2019-17351

## ğŸ” ì·¨ì•½ì  ê°œìš”

**ğŸ”— [ì»¤ë°‹ ë§í¬](https://github.com/torvalds/linux/commit/6f0c4d4f7c6c)** | **ğŸ”— [CVE ë§í¬](https://www.cvedetails.com/cve/CVE-2019-17351)** | **ğŸ”— [CWE ë§í¬](https://cwe.mitre.org/data/definitions/400.html)**

> Linux ì»¤ë„ì˜ Xen ë©”ëª¨ë¦¬ í’ì„ (balloon) ë“œë¼ì´ë²„ì˜ `balloon_process()` í•¨ìˆ˜ì—ì„œ ë°œìƒí•œ Resource Exhaustion(CWE-400) ì·¨ì•½ì ì…ë‹ˆë‹¤.

* **Source**: ì‚¬ìš©ìê°€ balloon_set_new_target()ì„ í†µí•´ target ê°’ì„ ì„¤ì • â†’ credit = target_pages - current_pages ê³„ì‚° â†’ balloon_process()ê°€ ì›Œí¬íì— ë“±ë¡ë¨

* **ì·¨ì•½ ì¡°ê±´**: balloon_stats.max_retry_count = RETRY_UNLIMITEDìœ¼ë¡œ ì„¤ì •ë¨ â†’ BP_EAGAIN ìƒíƒœê°€ ë°˜ë³µë˜ì–´ë„ ë£¨í”„ê°€ ì¢…ë£Œë˜ì§€ ì•ŠìŒ

* **Sink**: 
- credit > 0ì´ë©´ â†’ increase_reservation() â†’ Xen í•˜ì´í¼ì½œ ì‹¤íŒ¨ ì‹œ BP_EAGAIN ë°˜í™˜
- â†’ update_schedule()ì—ì„œ delay ì¦ê°€ ë° retry count ê°±ì‹ 
- â†’ BP_EAGAIN ìƒíƒœ ìœ ì§€ ì‹œ balloon_process()ê°€ ì›Œí¬íì— ë‹¤ì‹œ ë“±ë¡ë¨
- â†’ ì´ ë£¨í”„ê°€ ë¬´ì œí•œ ë°˜ë³µë˜ì–´ CPUì™€ ì›Œí¬í ìì›ì„ ì§€ì†ì ìœ¼ë¡œ ì†Œëª¨
- â†’ ê²°êµ­ CWE-400 (Resource Exhaustion) ìƒíƒœë¡œ ì´ì–´ì§


## íƒì§€ ê²°ê³¼ ìš”ì•½
ìŠ¬ë¼ì´ìŠ¤ ë¯¸íƒì§€

#### SARDëŠ” ì˜ íƒì§€í•˜ëŠ”ë° ì´ CVEëŠ” íƒì§€ ëª»í–ˆë˜ ì´ìœ 

1. **ë¶€ì ì ˆí•œ criterion**
    - CWE400ì˜ SARD/README.mdì— ë”°ë¥´ë©´ 
        > ```bash
        > C:\Users\user\Downloads\xsv-0.13.0-i686-pc-windows-gnu>xsv search -s predict 1 C:\Users\user\Desktop\SARD-vs-CVE\CWE400_RE\SARD\test_output.csv | xsv select criterion | xsv frequency -s criterion | xsv select value
        > 
        > value
        > strlen
        > fopen
        > fwrite
        > fclose
        > ```
    - ì´ ì·¨ì•½ì ì€ alloc_page()ì™€ xenmem_reservation_increase() ê°™ì€ ì»¤ë„ ë‚´ë¶€ í•¨ìˆ˜ì— ì˜ì¡´í•˜ì—¬ ë™ì‘í•˜ì§€ë§Œ, ì´ë“¤ ì¤‘ alloc_page()ëŠ” ì»¤ë„ ì „ìš© ë©”ëª¨ë¦¬ í• ë‹¹ í•¨ìˆ˜ì´ê³ , xenmem_reservation_increase()ëŠ” Xen í•˜ì´í¼ë°”ì´ì €ì™€ì˜ ë©”ëª¨ë¦¬ êµí™˜ì„ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ í•¨ìˆ˜ì´ë‹¤. ìŠ¬ë¼ì´ì„œê°€ ì´ëŸ¬í•œ í•¨ìˆ˜ë“¤ì„ criterionìœ¼ë¡œ ì¸ì‹í•˜ì§€ ëª»í•  ê²½ìš°, ì‹¤ì œë¡œëŠ” ì¬ì‹œë„ ë£¨í”„ ì¡°ê±´ì´ ì¡´ì¬í•˜ë”ë¼ë„ ìŠ¬ë¼ì´ìŠ¤ê°€ ìƒì„±ë˜ì§€ ì•Šì•„ ì·¨ì•½í•˜ì§€ ì•Šì€ ì½”ë“œë¡œ ì˜¤íŒë  ìˆ˜ ìˆë‹¤.
    - íŠ¹íˆ alloc_page()ëŠ” ìŠ¬ë¼ì´ì„œì˜ l_funcs í•„í„° ê¸°ì¤€ì— '\*alloc'ì€ í¬í•¨ë˜ì–´ ìˆìœ¼ë‚˜ 'alloc\*'ì€ í¬í•¨ë˜ì–´ ìˆì§€ ì•Šì•„ íƒì§€ë˜ì§€ ì•Šì€ ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤
    - ì´ í•¨ìˆ˜ëŠ” decrease_reservation() (before_balloon.c:459) ë‚´ë¶€ì—ì„œ í˜¸ì¶œë˜ë©°, ì‹¤ì œ í˜¸ì¶œ ìœ„ì¹˜ëŠ” before_balloon.c:471ì´ë‹¤.

---

## ì·¨ì•½ì  ì„¸ë¶€ ì‚¬í•­ â‘  â€“ decrease_reservation() ê²½ë¡œ (ë©”ëª¨ë¦¬ ë°˜í™˜)

### â—ï¸ ì·¨ì•½ ì½”ë“œ

#### Source1: ì‚¬ìš©ìê°€ ì„¤ì •í•œ target ê°’(before_balloon.c:558)
```c
void balloon_set_new_target(unsigned long target)
{
    /* No need for lock. Not read-modify-write updates. */
    balloon_stats.target_pages = target;
    schedule_delayed_work(&balloon_worker, 0); // ì›Œí¬í ë“±ë¡
}
```
ì‚¬ìš©ìê°€ balloon_set_new_target()ì„ í†µí•´ í˜„ì¬ë³´ë‹¤ ì‘ì€ target ê°’ì„ ì„¤ì •í•˜ë©´, ì‹œìŠ¤í…œì€ ë©”ëª¨ë¦¬ ë°˜í™˜ ì‘ì—…ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ balloon_process()ë¥¼ ì‹¤í–‰í•˜ê²Œ ëœë‹¤.

#### Source2: ì´ˆê¸° ì„¤ì •ê°’ â€“ ë¬´ì œí•œ ì¬ì‹œë„ í—ˆìš© (before_balloon.c:713)
```c
balloon_stats.max_retry_count = RETRY_UNLIMITED;
```

ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œ retry_countì— ì œí•œì´ ì—†ë„ë¡ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©°, ì´ëŠ” ì´í›„ BP_EAGAIN ìƒíƒœê°€ ë°˜ë³µë˜ì–´ë„ ë£¨í”„ê°€ ì¢…ë£Œë˜ì§€ ì•Šê²Œ ë§Œë“œëŠ” ì¤‘ìš”í•œ ì „ì œ ì¡°ê±´ì´ë‹¤.

#### Trace

#### Trace1: ì›Œí¬ í•­ëª© ì •ì˜ (before_balloon.c:154)
```c
static DECLARE_DELAYED_WORK(balloon_worker, balloon_process);
```

ballooning ì²˜ë¦¬ë¥¼ ìœ„í•œ í•¨ìˆ˜ì¸ balloon_process()ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡, ì§€ì—° ì›Œí¬ í•­ëª© balloon_workerê°€ ì •ì˜ë¨.

í•´ë‹¹ í•­ëª©ì€ ì¶”í›„ í•„ìš” ì‹œ ì›Œí¬íì— ë“±ë¡ë˜ì–´ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰ëœë‹¤

#### Trace2: ì›Œí¬í ë“±ë¡ (balloon_set_new_target, before_balloon.c:562)
```c
schedule_delayed_work(&balloon_worker, 0);
```

ì‚¬ìš©ìê°€ ìƒˆë¡œìš´ target ë©”ëª¨ë¦¬ í¬ê¸°ë¥¼ ì„¤ì •í•˜ë©´, balloon_set_new_target() í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê³ , ì´ ì‹œì ì— balloon_workerê°€ ì›Œí¬íì— ë“±ë¡ë˜ì–´ balloon_process() í•¨ìˆ˜ê°€ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰ë˜ë„ë¡ ì˜ˆì•½ëœë‹¤.

#### Trace3: credit ê³„ì‚° (current_credit, before_balloon.c:409)
```c
static long current_credit(void)
{
    return balloon_stats.target_pages - balloon_stats.current_pages;
}
```
balloon_process() í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ í˜¸ì¶œë˜ë©°, í˜„ì¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰(current_pages)ê³¼ ì‚¬ìš©ìê°€ ì„¤ì •í•œ ëª©í‘œ ë©”ëª¨ë¦¬(target_pages) ê°„ ì°¨ì´ë¥¼ ê³„ì‚°í•œë‹¤.

ì´ ê°’ì´ ìŒìˆ˜(credit < 0)ì¼ ê²½ìš°, ë©”ëª¨ë¦¬ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ê³  íŒë‹¨ëœë‹¤.

Trace4: ìŒìˆ˜ credit ì²˜ë¦¬ (balloon_process, before_balloon.c:541-542)
```c
static void balloon_process(struct work_struct *work)
{
	enum bp_state state = BP_DONE;
	long credit;


	do {
		mutex_lock(&balloon_mutex);

		credit = current_credit();

        // ì¤‘ëµ ..

		if (credit < 0)
			state = decrease_reservation(-credit, GFP_BALLOON); // ìŒìˆ˜ í¬ë ˆë”§ ì²˜ë¦¬

		state = update_schedule(state);

		mutex_unlock(&balloon_mutex);

		cond_resched();

	} while (credit && state == BP_DONE);

	/* Schedule more work if there is some still to be done. */
	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);
}
```

creditì´ ìŒìˆ˜ì´ë©´, decrease_reservation() í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ ì§€ì •ëœ ìˆ˜ë§Œí¼ì˜ í˜ì´ì§€ë¥¼ Xenì—ê²Œ ë°˜í™˜í•˜ë ¤ ì‹œë„í•œë‹¤.

#### Trace5: ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨ â†’ ì‹¤íŒ¨ ìƒíƒœ ë°˜í™˜ (decrease_reservation, before_balloon.c:471-474)
```c
// before_balloon.c:459-515
static enum bp_state decrease_reservation(unsigned long nr_pages, gfp_t gfp)
{
    // ì¤‘ëµ..

    for (i = 0; i < nr_pages; i++) {
        page = alloc_page(gfp);  // í˜ì´ì§€ í• ë‹¹ ì‹œë„
        if (page == NULL) {      // ë©”ëª¨ë¦¬ ë¶€ì¡± ì‹œ
            nr_pages = i;
            state = BP_EAGAIN;   // ì¬ì‹œë„ ìš”ì²­ -- ì£¼ìš” ë¶€ë¶„
            break;
        }
        // ... ë©”ëª¨ë¦¬ ì²˜ë¦¬ ...
    }
    // ... ë‚˜ë¨¸ì§€ ì²˜ë¦¬ ...
}
```

alloc_page(GFP_BALLOON)ì„ í†µí•´ í˜ì´ì§€ë¥¼ í• ë‹¹í•˜ë ¤ í•˜ì§€ë§Œ, ë©”ëª¨ë¦¬ê°€ ë¶€ì¡±í•˜ë©´ ì‹¤íŒ¨í•˜ê³  BP_EAGAIN ìƒíƒœë¥¼ ë°˜í™˜í•œë‹¤.

#### Trace6: ë¬´ì œí•œ ì¬ì‹œë„ ë¡œì§ (update_schedule, before_balloon.c:223)

```c
static enum bp_state update_schedule(enum bp_state state)
{
	// ì¤‘ëµ ..

	++balloon_stats.retry_count;

	if (balloon_stats.max_retry_count != RETRY_UNLIMITED &&
			balloon_stats.retry_count > balloon_stats.max_retry_count) {
		balloon_stats.schedule_delay = 1;
		balloon_stats.retry_count = 1;
		return BP_ECANCELED;
	}

	balloon_stats.schedule_delay <<= 1;

	if (balloon_stats.schedule_delay > balloon_stats.max_schedule_delay)
		balloon_stats.schedule_delay = balloon_stats.max_schedule_delay;

	return BP_EAGAIN;
}
```

max_retry_countê°€ RETRY_UNLIMITEDë¡œ ì„¤ì •ë˜ì–´ ìˆì–´, BP_EAGAIN ìƒíƒœê°€ ë°˜ë³µë˜ì–´ë„ ë£¨í”„ê°€ ì¤‘ë‹¨ë˜ì§€ ì•Šê³ , ì§€ì—° ì‹œê°„ë§Œ ì¦ê°€í•˜ë©´ì„œ ë°˜ë³µëœë‹¤.

#### Sink: ì¬ì‹œë„ ì›Œí¬í ì¬ë“±ë¡ (balloon_process, before_balloon.c:554)
```c
static void balloon_process(struct work_struct *work)
{
	// ì¤‘ëµ ..

	while (credit && state == BP_DONE);

	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ); // ë‹¤ì‹œ ë°˜ë³µë¨
}
```

#### **ë¬¸ì œì **:
alloc_page() í˜¸ì¶œì´ ë°˜ë³µì ìœ¼ë¡œ ì‹¤íŒ¨í•˜ë”ë¼ë„, balloon_process()ëŠ” ê³„ì† ì›Œí¬íì— ì¬ë“±ë¡ë˜ì–´ ì‹¤í–‰ëœë‹¤. ì´ ë°˜ë³µ ê³¼ì •ì—ì„œ ë‹¤ìŒê³¼ ê°™ì€ ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ê°€ ì§€ì†ì ìœ¼ë¡œ ì†Œëª¨ëœë‹¤:

 - CPU ì‚¬ì´í´: mutex_lock, update_schedule ë“±ì˜ ì»¤ë„ í•¨ìˆ˜ë“¤ì´ ë°˜ë³µ ì‹¤í–‰ë˜ë©° CPU ì‚¬ìš©ì´ ì§€ì†ë¨

 - ì›Œí¬í ìì›: schedule_delayed_work()ì— ì˜í•´ ì»¤ë„ ì›Œí¬íì™€ íƒ€ì´ë¨¸ íê°€ ë°˜ë³µ ì ìœ ë¨

 - ìƒíƒœ ìœ ì§€ ë¹„ìš©: retry_count, schedule_delay ë“±ì´ ë£¨í”„ë§ˆë‹¤ ê°±ì‹ ë˜ë©° ìƒíƒœ ê´€ë¦¬ ë¹„ìš©ì´ ë°œìƒí•¨

ë¹„ë¡ ë©”ëª¨ë¦¬ í˜ì´ì§€ ìì²´ëŠ” í• ë‹¹ë˜ì§€ ì•Šë”ë¼ë„, ì´ëŸ¬í•œ ë°˜ë³µ ì‹¤í–‰ì€ ì‹¤ì§ˆì ì¸ ì»¤ë„ ìì› ì†Œëª¨ë¥¼ ì´ˆë˜í•˜ë©°, ì™¸ë¶€ ì…ë ¥ì— ì˜í•´ ìœ ë„ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— CWE-400 (Resource Exhaustion) ì— í•´ë‹¹í•œë‹¤.

---


### âœ… ê°œì„  ì½”ë“œ

**íŒ¨ì¹˜ ìœ„ì¹˜**: 

1. ê³¼ë„í•œ ë©”ëª¨ë¦¬ ë°˜í™˜ ë°©ì§€ `after_balloon.c:541`

```diff
- if (credit < 0)
-     state = decrease_reservation(-credit, GFP_BALLOON);
+ if (credit < 0) {
+     long n_pages;
+
+     n_pages = min(-credit, si_mem_available());
+     state = decrease_reservation(n_pages, GFP_BALLOON);
+     if (state == BP_DONE && n_pages != -credit &&
+         n_pages < totalreserve_pages)
+         state = BP_EAGAIN;
+ }
```

2. ballooned í˜ì´ì§€ ì¶”ê°€ ì‹œ ê°€ìš© ë©”ëª¨ë¦¬ ì²´í¬ ì¶”ê°€ `after_balloon.c:588`
```diff
+ if (si_mem_available() < nr_pages)
+     return -ENOMEM;
```

3. ë¬´í•œ ì¬ì‹œë„ ë°©ì§€ â€“ retry count ì œí•œ ì¶”ê°€ `after_balloon.c:723`
```diff
- balloon_stats.max_retry_count = RETRY_UNLIMITED;
+ balloon_stats.max_retry_count = 4;
```


**ê°œì„  ë°©ë²•**:

1. ì‹¤ì œ ê°€ëŠ¥í•œ ë²”ìœ„ ë‚´ì—ì„œë§Œ ë©”ëª¨ë¦¬ ë°˜í™˜ ìˆ˜í–‰ â†’ ì‹œìŠ¤í…œ ì•ˆì •ì„± ìœ ì§€
- ê¸°ì¡´ì—ëŠ” ë°˜í™˜í•´ì•¼ í•  í˜ì´ì§€ ìˆ˜(-credit)ë§Œí¼ ë¬´ì¡°ê±´ decrease_reservation()ì„ í˜¸ì¶œí•˜ì˜€ìœ¼ë‚˜,
- ì´ì œëŠ” í˜„ì¬ ì‹œìŠ¤í…œì— ì‹¤ì œë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬(si_mem_available())ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë°˜í™˜ ê°€ëŠ¥í•œ ì–‘ì„ ì œí•œí•©ë‹ˆë‹¤.
- ë˜í•œ, ë°˜í™˜í•œ í˜ì´ì§€ ìˆ˜ê°€ ê¸°ëŒ€ì¹˜ë³´ë‹¤ ì ê³ , ì‹œìŠ¤í…œ ì˜ˆì•½ ë©”ëª¨ë¦¬(totalreserve_pages)ë¥¼ ì¹¨ë²”í•  ê²½ìš°, ì‹¤íŒ¨ ìƒíƒœ(BP_EAGAIN)ë¥¼ ê°•ì œë¡œ ì„¤ì •í•˜ì—¬ ê³¼ë„í•œ ë©”ëª¨ë¦¬ í•´ì œë¥¼ ë§‰ìŠµë‹ˆë‹¤.

2. ì‹œë„ ì „ ê°€ìš© ìì› í™•ì¸ â†’ ë¶ˆí•„ìš”í•œ ì‘ì—… íšŒí”¼
- add_ballooned_pages() í•¨ìˆ˜ì—ì„œ ballooned í˜ì´ì§€ë¥¼ ì¶”ê°€í•˜ê¸° ì „ì—, ì‹œìŠ¤í…œì— ì‹¤ì œë¡œ ì¶©ë¶„í•œ ì—¬ìœ  ë©”ëª¨ë¦¬ê°€ ìˆëŠ”ì§€ë¥¼ si_mem_available()ë¡œ ì ê²€í•©ë‹ˆë‹¤.
- ì´ë¥¼ í†µí•´ ë©”ëª¨ë¦¬ ë¶€ì¡± ìƒíƒœì—ì„œ ë¶ˆí•„ìš”í•œ ì‹œë„ë¥¼ í•˜ì§€ ì•Šê³ , ì‚¬ì „ì— ì¤‘ë‹¨í•˜ì—¬ ë¦¬ì†ŒìŠ¤ ì†Œëª¨ë¥¼ ì˜ˆë°©í•©ë‹ˆë‹¤.

3. ì¬ì‹œë„ íšŸìˆ˜ ì œí•œ â†’ ë£¨í”„ ê¸°ë°˜ ìì› ê³ ê°ˆ ë°©ì§€ (CWE-400 ì™„í™”)
- ê¸°ì¡´ì—ëŠ” ì¬ì‹œë„ íšŸìˆ˜ ì œí•œì´ ì—†ì–´ì„œ BP_EAGAIN ìƒíƒœê°€ ë°˜ë³µë  ê²½ìš° balloon_process()ê°€ ë¬´í•œíˆ ì›Œí¬íì— ë“±ë¡ë˜ì–´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤.
- íŒ¨ì¹˜ì—ì„œëŠ” max_retry_count ê°’ì„ 4ë¡œ ì œí•œí•¨ìœ¼ë¡œì¨, ì¬ì‹œë„ ë£¨í”„ì— ë¹ ì§€ëŠ” ê²ƒì„ ë°©ì§€í•˜ê³  ì‹œìŠ¤í…œ ìì› ê³ ê°ˆ(CPU, ì›Œí¬í)ì„ ì°¨ë‹¨í•©ë‹ˆë‹¤.
