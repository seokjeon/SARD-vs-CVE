[{"FileName": "before.c", "Caller": "init_entity_runnable_average", "Source": false, "Sink": false, "idx": 0, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 703, "label": -3, "slices": ["void init_entity_runnable_average(struct sched_entity *se)\n", "\tstruct sched_avg *sa = &se->avg;\n", "\tmemset(sa, 0, sizeof(*sa));\n", "\tif (entity_is_task(se))\n", "\t\tsa->runnable_load_avg = sa->load_avg = scale_load_down(se->load.weight);\n"], "tokenized": "void FUNC1(struct STRUCT1 *Var1)\nstruct STRUCT2 *Var2=&Var1->memberVar1; \nmemset(Var2,0,sizeof (*Var2)); \nif (FUNC2(Var1))\nVar2->memberVar1=Var2->memberVar2=FUNC3(Var1->memberVar2.memberVar1); \n"}, {"FileName": "before.c", "Caller": "update_numa_stats", "Source": false, "Sink": false, "idx": 1, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 1476, "label": -3, "slices": ["static void update_numa_stats(struct numa_stats *ns, int nid)\n", "\tint cpu;\n", "\tmemset(ns, 0, sizeof(*ns));\n", "\t\tstruct rq *rq = cpu_rq(cpu);\n", "\t\tns->load += weighted_cpuload(rq);\n", "\t\tns->compute_capacity += capacity_of(cpu);\n"], "tokenized": "static void FUNC1(struct STRUCT1 *Var1,int  Var2)\nint  Var3; \nmemset(Var1,0,sizeof (*Var1)); \nstruct STRUCT2 *STRUCT2=FUNC2(Var3); \nVar1->memberVar1  STRUCT3 FUNC3(STRUCT2); \nVar1->memberVar2  STRUCT3 FUNC4(Var3); \n"}, {"FileName": "before.c", "Caller": "update_task_scan_period", "Source": false, "Sink": false, "idx": 2, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 1978, "label": -3, "slices": ["static void update_task_scan_period(struct task_struct *p,\n\t\t\tunsigned long shared, unsigned long private)\n", "\t\t\tunsigned long shared, unsigned long private)\n", "\tunsigned int period_slot;\n", "\tint lr_ratio, ps_ratio;\n", "\tint diff;\n", "\tunsigned long remote = p->numa_faults_locality[0];\n", "\tunsigned long local = p->numa_faults_locality[1];\n", "\tif (local + shared == 0 || p->numa_faults_locality[2]) {\n", "\t\tp->numa_scan_period = min(p->numa_scan_period_max,\n\t\t\tp->numa_scan_period << 1);\n", "\t\tp->mm->numa_next_scan = jiffies +\n", "\tperiod_slot = DIV_ROUND_UP(p->numa_scan_period, NUMA_PERIOD_SLOTS);\n", "\tlr_ratio = (local * NUMA_PERIOD_SLOTS) / (local + remote);\n", "\tps_ratio = (private * NUMA_PERIOD_SLOTS) / (private + shared);\n", "\tif (ps_ratio >= NUMA_PERIOD_THRESHOLD) {\n", "\t\tint slot = ps_ratio - NUMA_PERIOD_THRESHOLD;\n", "\t\tif (!slot)\n", "\t\t\tslot = 1;\n", "else\n", "\t} else if (lr_ratio >= NUMA_PERIOD_THRESHOLD) {\n", "\t\tint slot = lr_ratio - NUMA_PERIOD_THRESHOLD;\n", "\t\tif (!slot)\n", "\t\t\tslot = 1;\n", "\t\tdiff = slot * period_slot;\n", "else\n", "\t\tint ratio = max(lr_ratio, ps_ratio);\n", "\t\tdiff = -(NUMA_PERIOD_THRESHOLD - ratio) * period_slot;\n", "\tp->numa_scan_period = clamp(p->numa_scan_period + diff,\n\t\t\ttask_scan_min(p), task_scan_max(p));\n", "\tmemset(p->numa_faults_locality, 0, sizeof(p->numa_faults_locality));\n"], "tokenized": "static void FUNC1(struct STRUCT1 *Var1,\nunsigned long  Var2,unsigned long private )\nunsigned long  Var2,unsigned long private )\nunsigned int  Var3; \nint  Var4,Var5; \nint  Var6; \nunsigned long  Var7=Var1->memberVar1[0]; \nunsigned long  Var8=Var1->memberVar1[1]; \nif (Var8+Var2 == 0||Var1->memberVar1[2]){\nVar1->memberVar2=FUNC2(Var1->memberVar3,\nVar1->memberVar2<<1); \nVar1->memberVar4->memberVar1=Var9+\nVar3=FUNC3(Var1->memberVar2,Var10); \nVar4=(Var8 *Var10)/(Var8+Var7); \nVar5=(private *Var10)/(private +Var2); \nif (Var5 >=  Var11){\nint  Var12=Var5-Var11; \nif (!Var12)\nVar12=1; \nelse \n}else if (Var4 >=  Var11){\nint  Var12=Var4-Var11; \nif (!Var12)\nVar12=1; \nVar6=Var12 *Var3; \nelse \nint  Var13=FUNC4(Var4,Var5); \nVar6=-(Var11-Var13)*Var3; \nVar1->memberVar2=FUNC5(Var1->memberVar2+Var6,\nFUNC6(Var1),FUNC7(Var1)); \nmemset(Var1->memberVar1,0,sizeof (Var1->memberVar1)); \n"}, {"FileName": "before.c", "Caller": "task_numa_fault", "Source": false, "Sink": false, "idx": 3, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 2375, "label": -3, "slices": ["\tstruct task_struct *p = current;\n", "\tbool migrated = flags & TNF_MIGRATED;\n", "\tint cpu_node = task_node(current);\n", "\tint local = !!(flags & TNF_FAULT_LOCAL);\n", "\tstruct numa_group *ng;\n", "\tint priv;\n", "\tif (!static_branch_likely(&sched_numa_balancing))\n", "\tif (!p->mm)\n", "\tif (unlikely(!p->numa_faults)) {\n", "\t\tint size = sizeof(*p->numa_faults) *\n", "\t\tp->numa_faults = kzalloc(size, GFP_KERNEL|__GFP_NOWARN);\n", "\t\tif (!p->numa_faults)\n", "\t\tp->total_numa_faults = 0;\n", "\t\tmemset(p->numa_faults_locality, 0, sizeof(p->numa_faults_locality));\n", "\tif (unlikely(last_cpupid == (-1 & LAST_CPUPID_MASK))) {\n", "else\n", "\t\tpriv = cpupid_match_pid(p, last_cpupid);\n", "\t\tif (!priv && !(flags & TNF_NO_GROUP))\n", "\t\t\ttask_numa_group(p, last_cpupid, flags, &priv);\n", "\tng = p->numa_group;\n", "\tif (time_after(jiffies, p->numa_migrate_retry)) {\n", "\t\ttask_numa_placement(p);\n", "\t\tnuma_migrate_preferred(p);\n", "\tif (migrated)\n", "\t\tp->numa_pages_migrated += pages;\n", "\tif (flags & TNF_MIGRATE_FAIL)\n", "\t\tp->numa_faults_locality[2] += pages;\n", "\tp->numa_faults[task_faults_idx(NUMA_MEMBUF, mem_node, priv)] += pages;\n", "\tp->numa_faults[task_faults_idx(NUMA_CPUBUF, cpu_node, priv)] += pages;\n", "\tp->numa_faults_locality[local] += pages;\n"], "tokenized": "struct STRUCT1 *Var1=Var2; \nbool  Var3=Var4&Var5; \nint  Var6=FUNC1(Var2); \nint  Var7=!!(Var4&Var8); \nstruct STRUCT2 *Var9; \nint  Var10; \nif (!FUNC2(&Var11))\nif (!Var1->memberVar1)\nif (FUNC3(!Var1->memberVar2)){\nint size =sizeof (*Var1->memberVar2)*\nVar1->memberVar2=FUNC4(size ,Var12|Var13); \nif (!Var1->memberVar2)\nVar1->memberVar3=0; \nmemset(Var1->memberVar4,0,sizeof (Var1->memberVar4)); \nif (FUNC3(STRUCT3 == (-1&Var14))){\nelse \nVar10=FUNC5(Var1,STRUCT3); \nif (!Var10&&!(Var4&Var15))\nFUNC6(Var1,STRUCT3,Var4,&Var10); \nVar9=Var1->memberVar5; \nif (FUNC7(Var16,Var1->memberVar6)){\nFUNC8(Var1); \nFUNC9(Var1); \nif (Var3)\nVar1->memberVar7  STRUCT4  Var17; \nif (Var4&Var18)\nVar1->memberVar4[2]STRUCT4  Var17; \nVar1->memberVar2[FUNC10(Var19,Var20,Var10)]STRUCT4  Var17; \nVar1->memberVar2[FUNC10(Var21,Var6,Var10)]STRUCT4  Var17; \nVar1->memberVar4[Var7]STRUCT4  Var17; \n"}, {"FileName": "before.c", "Caller": "update_sg_lb_stats", "Source": false, "Sink": false, "idx": 4, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 8172, "label": -3, "slices": ["\t\t\t\t      struct sg_lb_stats *sgs,\n", "\tint local_group = cpumask_test_cpu(env->dst_cpu, sched_group_span(group));\n", "\tint load_idx = get_sd_load_idx(env->sd, env->idle);\n", "\tunsigned long load;\n", "\tint i, nr_running;\n", "\tmemset(sgs, 0, sizeof(*sgs));\n", "\t\tstruct rq *rq = cpu_rq(i);\n", "\t\tsgs->group_load += load;\n", "\t\tsgs->group_util += cpu_util(i);\n", "\t\tsgs->sum_nr_running += rq->cfs.h_nr_running;\n", "\t\tsgs->nr_numa_running += rq->nr_numa_running;\n", "\t\tsgs->nr_preferred_running += rq->nr_preferred_running;\n", "\t\tsgs->sum_weighted_load += weighted_cpuload(rq);\n", "\t\tif (!nr_running && idle_cpu(i))\n", "\t\t\tsgs->idle_cpus++;\n", "\t\tif (env->sd->flags & SD_ASYM_CPUCAPACITY &&\n\t\t    sgs->group_misfit_task_load < rq->misfit_task_load) {\n", "\t\t\tsgs->group_misfit_task_load = rq->misfit_task_load;\n", "\tsgs->group_capacity = group->sgc->capacity;\n", "\tsgs->avg_load = (sgs->group_load*SCHED_CAPACITY_SCALE) / sgs->group_capacity;\n", "\tif (sgs->sum_nr_running)\n", "\t\tsgs->load_per_task = sgs->sum_weighted_load / sgs->sum_nr_running;\n", "\tsgs->group_weight = group->group_weight;\n", "\tsgs->group_no_capacity = group_is_overloaded(env, sgs);\n", "\tsgs->group_type = group_classify(group, sgs);\n"], "tokenized": "struct STRUCT1 *Var1,\nint  Var2=FUNC1(Var3->memberVar1,FUNC2(Var4)); \nint  Var5=FUNC3(Var3->memberVar2,Var3->memberVar3); \nunsigned long  Var6; \nint  Var7,Var8; \nmemset(Var1,0,sizeof (*Var1)); \nstruct STRUCT2 *STRUCT2=FUNC4(Var7); \nVar1->memberVar1  STRUCT3  Var6; \nVar1->memberVar2  STRUCT3 FUNC5(Var7); \nVar1->memberVar3  STRUCT3  STRUCT2->memberVar1.memberVar1; \nVar1->memberVar4  STRUCT3  STRUCT2->memberVar2; \nVar1->memberVar5  STRUCT3  STRUCT2->memberVar3; \nVar1->memberVar6  STRUCT3 FUNC6(STRUCT2); \nif (!Var8&&FUNC7(Var7))\nVar1->STRUCT4  Var9; \nif (Var3->memberVar2->memberVar1&Var10&&\nVar1->memberVar7<STRUCT2->memberVar4){\nVar1->memberVar7=STRUCT2->memberVar4; \nVar1->memberVar8=Var4->memberVar1->memberVar1; \nVar1->memberVar9=(Var1->memberVar1 *Var11)/Var1->memberVar8; \nif (Var1->memberVar3)\nVar1->memberVar10=Var1->memberVar6/Var1->memberVar3; \nVar1->memberVar11=Var4->memberVar2; \nVar1->memberVar12=FUNC8(Var3,Var1); \nVar1->memberVar13=FUNC9(Var4,Var1); \n"}]