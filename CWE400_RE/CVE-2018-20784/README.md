# 📁 CVE-2018-20784

## 🔍 취약점 개요

🔗 [커밋 링크](https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0) | 🔗 [CVE 링크](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20784) | 🔗 [CWE 링크 (CWE-400)](https://cwe.mitre.org/data/definitions/400.html)

> Linux 커널 Completely Fair Scheduler(CFS)의 `update_blocked_averages()` 함수에서,
리스트 순회 루프(`for_each_leaf_cfs_rq_safe`)가 리스트 손상 시 종료되지 않고 무한 루프에 빠져 서비스 거부(DoS)를 유발하는 취약점입니다.

* **Source**: CFS 런큐 리스트 `rq->leaf_cfs_rq_list`
* **취약 조건**: 리스트 무결성이 손상된 경우 순회 포인터(`pos`)가 정상 갱신되지 않음
* **Sink**: `for_each_leaf_cfs_rq_safe` 매크로 반복문이 종료되지 않고 무한 반복

---

## 탐지 결과 요약
CVE 설명에 기반해 슬라이스를 수집한 결과,

| 총 슬라이스 수 | 취약으로 탐지 | 정상으로 탐지 |
| :------: | :-----: | :-----: |
|    5개    |    2개   |    3개   |


탐지된 슬라이스는 모두 `memset()` 호출 단위로 구성되어 있음.

| FileName       | Caller                          | Source |  Sink | idx | CWE-ID |    category    | criterion | line | label | token\_length | predict |
| :------------- | :------------------------------ | :----: | :---: | :-: | :----: | :------------: | :-------: | :--: | :---: | :-----------: | :-----: |
| before\_fair.c | init\_entity\_runnable\_average |  False | False |  0  |  CWE-  | CallExpression |   memset  |  703 |   -3  |       85      |    1    |
| before\_fair.c | update\_numa\_stats             |  False | False |  1  |  CWE-  | CallExpression |   memset  | 1476 |   -3  |       95      |    1    |
| before\_fair.c | update\_task\_scan\_period      |  False | False |  2  |  CWE-  | CallExpression |   memset  | 1978 |   -3  |      409      |    0    |
| before\_fair.c | task\_numa\_fault               |  False | False |  3  |  CWE-  | CallExpression |   memset  | 2375 |   -3  |      419      |    0    |
| before\_fair.c | update\_sg\_lb\_stats           |  False | False |  4  |  CWE-  | CallExpression |   memset  | 8172 |   -3  |      390      |    0    |

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

1. **슬라이스 추출 기준 한계**

    - 본 취약점은 `for_each_leaf_cfs_rq_safe` 매크로 기반 반복문 내부에서 발생하지만,
      슬라이서는 **함수 호출(CallExpression)** 단위로 슬라이스를 생성하여 루프 구조가 슬라이스에 포함되지 않음
    - 일반적으로 `memset()` 과 같은 함수 호출이 취약 동작(sink)이기 때문에 'memest()'을 criterion 삼아 슬라이스를 뽑아 탐지가 가능하나
      CVE-2018-20784는 'memset()' 호출에서 취약점이 발생하지 않으며
      'list_del_leaf_cfs_rq'와 같은 리스트 삭제 동작 및 리스트 순회 무결성 손상에 의해 발생하는 구조적 취약점임.
    - update_blocked_averages()함수에는 memset()호출이 존재하지 않아 슬라이스가 생성되지 않아 탐지되지 않음

      기대하는 슬라이스

      ```
      for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
          if(cfs_rq_is_decayed(cfs_rq))
              list_del_leaf_cfs_rq(cfs_rq); // sink가 될 수 있는 동작
      }
      ```
      실제 슬라이스

      ```
      memset(ns, 0, sizeof(*ns))
      ```

        
2. **리스트 순회 조건 변수 추적 실패**

      - **`rq->leaf_cfs_rq_list`**: 스케줄러 런큐의 leaf runqueue 리스트.
      - **`pos` 포인터**: 리스트 노드를 순회하면서 다음 노드를 가리켜야 하지만,
                         리스트 손상 시 정상 갱신되지 않음 → 무한 루프 발생.


      - 정상 흐름:
        'pos'가 리스트의 다음 엔트리를 정상적으로 가리키며 순회 종료
      - 비정상 흐름:
        리스트 손상으로 'pos'가 'NULL'이나 순환되지 않는 노드를 가리킴 -> 루프 탈출 불가 -> 무한 루프 발생
        

## 취약점 세부 사항

### 📁 관련 파일 소개

| 파일명             | 설명             |
| :-------------- | :------------- |
| `before_fair.c` | 취약 코드(수정 전) 포함 |
| `after_fair.c`  | 개선 코드(수정 후) 포함 |

---

### ❗️ 취약 코드

#### Source: `rq->leaf_cfs_rq_list` 리스트 (`before_fair.c:357`)
#### Sink: `for_each_leaf_cfs_rq_safe` 매크로 기반 무한 순회 (`before_fair.c:7682`)

```c
for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {   // (Line 7682) 리스트 순회 반복문
    ...
		/*
		 * There can be a lot of idle CPU cgroups.  Don't let fully
		 * decayed cfs_rqs linger on the list.
		 */
		if (cfs_rq_is_decayed(cfs_rq))
			list_del_leaf_cfs_rq(cfs_rq); // sink가 될 수 있는 동작
}
```
**문제점**: 리스트 순회 구조, 포인터 갱신 흐름, 무한 반복 가능성을 모델 입력에서 제공하지 않음.
**결과**: 모델이 무한 루프 위험을 학습할 수 없음.


| 변수                     | 설명                                             |
| :--------------------- | :--------------------------------------------- |
| `rq->leaf_cfs_rq_list` | 스케줄러 런큐에 등록된 leaf runqueue 리스트.                |
| `pos`                  | 현재 순회 중인 리스트 노드 포인터. 다음 엔트리를 가리켜야 루프 정상 종료 가능. |


정상 흐름

`pos`가 리스트 내 다음 엔트리를 가리키며 순회 완료 → 루프 종료.

비정상 흐름

리스트 손상 시 `pos`가 갱신되지 않음 → 루프 탈출 실패 → 무한 반복 발생.

---
### ✅ 개선 코드

**패치 위치**: `after_fair.c:356`

```
#define for_each_leaf_cfs_rq(rq, cfs_rq) \
    list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)
```

**개선 방법**:

* 기존 `for_each_leaf_cfs_rq_safe` 매크로를,
  RCU 기반 안전 리스트 순회 매크로(`list_for_each_entry_rcu`)로 변경.
* RCU(Read-Copy-Update) 기법을 통해 리스트 동기화, 삭제/변경 상황에서도 안전한 순회 보장.
* 포인터 갱신이 보장되므로 무한 루프 위험 제거.

---

## 탐지 결과



| FileName | Caller                       | Source | Sink  | idx | CWE-ID | category       | criterion | line | label | token_length | predict |
|----------|------------------------------|--------|-------|-----|--------|----------------|-----------|------|-------|--------------|---------|
| before.c | init_entity_runnable_average | False  | False | 0   | CWE-   | CallExpression | memset    | 703  | -3    | 85           | 1       |
| before.c | update_numa_stats            | False  | False | 1   | CWE-   | CallExpression | memset    | 1476 | -3    | 95           | 1       |
| before.c | update_task_scan_period      | False  | False | 2   | CWE-   | CallExpression | memset    | 1978 | -3    | 409          | 0       |
| before.c | task_numa_fault              | False  | False | 3   | CWE-   | CallExpression | memset    | 2375 | -3    | 419          | 0       |
| before.c | update_sg_lb_stats           | False  | False | 4   | CWE-   | CallExpression | memset    | 8172 | -3    | 390          | 0       |


