# ğŸ“ CVE-2018-16863

## ğŸ” ì·¨ì•½ì  ê°œìš”

**ğŸ”— [ì»¤ë°‹ ë§í¬](https://invent.kde.org/plasma/plasma-workspace/-/commit/9db872df82c258315c6ebad800af59e81ffb9212)** | **ğŸ”— [CVE ë§í¬](https://www.cvedetails.com/cve/CVE-2018-16863/)**  

> RHSA-2018:2918ì´ CVE-2018-16509ë¥¼ ì™„ì „íˆ ìˆ˜ì •í•˜ì§€ ì•Šì€ ê²ƒìœ¼ë¡œ í™•ì¸ë˜ì—ˆë‹¤. ê³µê²©ìëŠ” ì´ ê²°í•¨ì˜ ë˜ ë‹¤ë¥¸ ë³€ì¢…ì„ ì•…ìš©í•˜ê³  -dSAFER ë³´í˜¸ë¥¼ ìš°íšŒí•˜ì—¬ ì˜ˆë¥¼ ë“¤ì–´ íŠ¹ë³„íˆ ì œì‘ëœ PostScript ë¬¸ì„œë¥¼ í†µí•´ ì„ì˜ì˜ ì…¸ ëª…ë ¹ì„ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.

**ì·¨ì•½ì  ì¢…ë¥˜**: [[CWE-78](https://cwe.mitre.org/data/definitions/78.html)] OS Command Injection

* **ì·¨ì•½ ì¡°ê±´**: ì…ë ¥ê°’ ê²€ì¦ ì—†ì´(ì´ ì½”ë“œì˜ ê²½ìš°, ë””ë°”ì´ìŠ¤ ì´ˆê¸°í™”ë¥¼ ì§„í–‰í•œ í›„ì— ì„¤ì¹˜ê°€ ì´ë£¨ì–´ì ¸ì•¼í•˜ëŠ”ë° ì´ˆê¸°í™”í•˜ëŠ” ì½”ë“œê°€ ì—†ì—ˆìŒ) ëª…ë ¹ ì‹¤í–‰ ê²½ë¡œì— ì§ì ‘ ì‚¬ìš©ë¨

* **Sink**: ì·¨ì•½ì ì„ ë°œíœ˜í•˜ëŠ” í•¨ìˆ˜ê°€ ìˆëŠ”ê²ƒì€ ì•„ë‹˜. ì´ˆê¸° í™˜ê²½ ì„¤ì¹˜ì‹œì— ë°œìƒí•˜ëŠ” ë¬¸ì œë¡œ nullì¸ì§€ í™•ì¸í•˜ëŠ” ì½”ë“œê°€ ë¯¸ë¹„ (nullì´ ì•„ë‹ˆë¼ë©´ í•´ë‹¹ ì„¤ì¹˜ ê³µê°„ì— ì„ì˜ì˜ ëª…ë ¹ì´ ë‹´ê²¨ìˆë‹¤ë©´ ì·¨ì•½ì ì´ ë°œí˜„ë˜ëŠ” ìƒí™©)

---

## íƒì§€ ê²°ê³¼ ìš”ì•½
cve ì„¤ëª…ì— ë‚˜ì˜¨ ì·¨ì•½í•œ í•¨ìˆ˜(Caller)ì— ëŒ€í•œ ìŠ¬ë¼ì´ìŠ¤ë§Œ ê³ ë ¤í–ˆì„ ë•Œ,

| ì´ ìŠ¬ë¼ì´ìŠ¤ ìˆ˜ |  ì·¨ì•½ìœ¼ë¡œ íƒì§€ | ì •ìƒìœ¼ë¡œ íƒì§€ |
| --------  | -- | -- |
| 0ê°œ       | 0ê°œ | 0ê°œ |

\* cve ì„¤ëª…ì— ë‚˜ì˜¨ ì·¨ì•½í•œ í•¨ìˆ˜(Caller) && Sinkì™€ ê´€ë ¨ëœ ìŠ¬ë¼ì´ìŠ¤ ë°ì´í„°ë§Œ ì¶”ì¶œ
ì—†ë‹¤.


#### SARDëŠ” ì˜ íƒì§€í•˜ëŠ”ë° ì´ CVEëŠ” íƒì§€ ëª»í–ˆë˜ ì´ìœ 

í˜„ì¬ ì·¨ì•½ì ì´ ë°œìƒí•˜ëŠ” í•¨ìˆ˜ gs_nulldevice() ì•ˆì—ëŠ” l_funcs ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” í•¨ìˆ˜ê°€ ì—†ì–´ criterionì´ ì—†ê¸° ë•Œë¬¸ì— ì¡íˆëŠ”ê²Œ ì—†ë‹¤.

---

### âš ï¸ íƒì§€ ê²°ê³¼ ë¬¸ì œì 

í˜„ì¬ íƒì§€ ê²°ê³¼ì—ì„œ ëª¨ë“  ìŠ¬ë¼ì´ìŠ¤ê°€ ì •ìƒ(ë¼ë²¨ 0)ìœ¼ë¡œ íŒì •ë˜ì—ˆìœ¼ë‚˜, ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê¸°ìˆ ì  í•œê³„ë¡œ ì¸í•œ ì˜¤íƒìœ¼ë¡œ íŒë‹¨ë©ë‹ˆë‹¤:

1. **crietrionì´ ë ë§Œí•œ í•¨ìˆ˜ê°€ callerì— ì—†ìŒ**

## ì·¨ì•½ì  ì„¸ë¶€ ì‚¬í•­

### ğŸ“ ê´€ë ¨ íŒŒì¼ ì†Œê°œ

| íŒŒì¼ëª…            | ì„¤ëª…              |
| -------------- | --------------- |
| `before_device.c` | ì·¨ì•½ ì½”ë“œ (ìˆ˜ì • ì „) í¬í•¨ |
| `after_gsdevice.c`  | ê°œì„  ì½”ë“œ (ìˆ˜ì • í›„) í¬í•¨ |

---

### â—ï¸ ì·¨ì•½ ì½”ë“œ

#### Source: `before_device.c` 
CVEì—ì„œ Source íŒŒì•…ì´ ì–´ë ¤ìš°ë©´ ìƒëµ ê°€ëŠ¥
```c
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;
    gs_gstate *spgs;
    bool saveLockSafety = false;
    if (pgs->device == NULL || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        if (gs_currentdevice_inline(pgs) != NULL)
            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if (gs_setdevice_no_erase(pgs, ndev) < 0) {
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");
            spgs = pgs->saved;
            if (spgs != NULL) {
                while (spgs->saved) spgs = spgs->saved;
                gs_currentdevice_inline(pgs) = gs_currentdevice_inline(spgs);
                rc_increment(gs_currentdevice_inline(pgs));
            }
            code = gs_note_error(gs_error_Fatal);
        }
        if (gs_currentdevice_inline(pgs) != NULL)
            gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
    }
    return code;
}
```

**ë¬¸ì œì **:
LockSafetyParamsëŠ” ë””ë°”ì´ìŠ¤ê°€ ë³´ì•ˆ ê´€ë ¨ ì„¤ì •ì„ ë”°ë¥´ëŠ”ì§€ë¥¼ ì œì–´í•œë‹¤.
ë³µêµ¬ ê³¼ì •ì—ì„œ ì´ í”Œë˜ê·¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šê±°ë‚˜ ì˜ëª»ëœ ê°’ìœ¼ë¡œ ì„¤ì •ë˜ë©´, ì‹œìŠ¤í…œì´ ë³´ì•ˆ ê²€ì‚¬ë¥¼ ìš°íšŒí•˜ê±°ë‚˜ ë¶ˆì•ˆì •í•œ ìƒíƒœë¡œ ë™ì‘í•  ìˆ˜ ìˆìŒ

---

### âœ… ê°œì„  ì½”ë“œ

**íŒ¨ì¹˜ ìœ„ì¹˜**: `after_gsdevice.c`

```c
/* Select a null device. */
int
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;
    bool saveLockSafety = false;
    if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        if (gs_currentdevice_inline(pgs) != NULL)
            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
        /*
         * Internal devices have a reference count of 0, not 1,
         * aside from references from graphics states.
         */
        /* There is some strange use of the null device in the code.  I need
           to sort out how the icc profile is best handled with this device.
           It seems to inherit properties from the current device if there
           is one */
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");
        gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
    }
    return code;
}
```

**ê°œì„  ë°©ë²•**:
1. gs_currentdevice_inline(pgs)->LockSafetyParams ê°’ì„ saveLockSafety ë³€ìˆ˜ì— ë°±ì—…í•¨
```c
if (gs_currentdevice_inline(pgs) != NULL)
    saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
```
2. ìƒˆë¡œìš´ null ë””ë°”ì´ìŠ¤ë¥¼ ìƒì„± ë° ì„¤ì • ì‹œë„

3. ë””ë°”ì´ìŠ¤ ì„¤ì • í›„, í˜„ì¬ ë””ë°”ì´ìŠ¤ì˜ LockSafetyParamsë¥¼ ë³µì›
```c
gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
```
---

## íƒì§€ ê²°ê³¼
ì—†ìŠµë‹ˆë‹¤.