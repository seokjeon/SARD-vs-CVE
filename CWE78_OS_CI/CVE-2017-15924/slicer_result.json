[{"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 0, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 98, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 1, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 98, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 2, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 101, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 3, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fopen", "line": 102, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 4, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 110, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 5, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 111, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 6, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "atoi", "line": 111, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 7, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 112, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 8, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 113, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 9, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 114, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 10, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 115, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 11, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 116, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 12, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 117, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 13, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 118, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "build_config", "Source": false, "Sink": false, "idx": 14, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fclose", "line": 119, "label": -3, "slices": ["build_config(char *prefix, struct server *server)\n", "    char *path    = NULL;\n", "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n", "    path = ss_malloc(path_size);\n", "    FILE *f = fopen(path, \"w+\");\n", "    if (f == NULL) {\n", "    fprintf(f, \"{\\n\");\n", "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n", "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n", "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n", "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n", "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n", "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n", "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n", "    fprintf(f, \"\\n}\\n\");\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 15, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 133, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 16, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 134, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    build_config(working_dir, server);\n", "    if (server->method) method = server->method;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 17, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 140, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 18, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 141, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 19, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 144, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 20, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 145, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 21, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 149, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 22, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 150, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 23, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 154, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 24, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 155, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 25, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 158, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 26, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 159, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 27, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 162, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 28, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 163, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 29, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 166, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 30, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 167, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 31, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 170, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 32, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 171, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 33, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 174, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 34, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 175, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 35, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 178, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 36, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 179, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 37, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 182, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 38, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 183, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 39, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 186, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 40, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 187, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 41, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 190, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 42, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 191, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 43, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 194, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 44, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 195, "label": -3, "slices": ["construct_command_line(struct manager_ctx *manager, struct server *server)\n", "    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 45, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 199, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "construct_command_line", "Source": false, "Sink": false, "idx": 46, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 200, "label": -3, "slices": ["    static char cmd[BUF_SIZE];\n", "    char *method = manager->method;\n", "    int i;\n", "    memset(cmd, 0, BUF_SIZE);\n", "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n", "    if (manager->acl != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n", "    if (manager->timeout != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n", "    if (manager->nofile) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n", "    if (manager->user != NULL) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n", "    if (manager->verbose) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n", "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n", "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n", "    if (server->fast_open[0] == 0 && manager->fast_open) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n", "    if (manager->ipv6first) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n", "    if (manager->mtu) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n", "    if (server->plugin == NULL && manager->plugin) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n", "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n", "    for (i = 0; i < manager->nameserver_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n", "    for (i = 0; i < manager->host_num; i++) {\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n", "        int len = strlen(cmd);\n", "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n", "    if (verbose) {\n", "        LOGI(\"cmd: %s\", cmd);\n", "    return cmd;\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 47, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 258, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "        LOGE(\"%s\", error_buf);\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "else\n", "                LOGE(\"invalid data: %s\", data);\n", "    json_value_free(obj);\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 48, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 266, "label": -3, "slices": ["    char *data = get_data(buf, len);\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    memset(server, 0, sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "    return server;\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 49, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 272, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 50, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strncpy", "line": 274, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    memset(server, 0, sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "    return server;\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 51, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 278, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 52, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strncpy", "line": 280, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    memset(server, 0, sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "    return server;\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 53, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 282, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 54, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strdup", "line": 284, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    memset(server, 0, sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "    return server;\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 55, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 286, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 56, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strncpy", "line": 288, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    memset(server, 0, sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "    return server;\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 57, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 290, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 58, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strdup", "line": 292, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    memset(server, 0, sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "    return server;\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 59, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 294, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 60, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strdup", "line": 296, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    memset(server, 0, sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "    return server;\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 61, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 298, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n"]}, {"FileName": "manager.c", "Caller": "get_server", "Source": false, "Sink": false, "idx": 62, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strdup", "line": 300, "label": -3, "slices": ["get_server(char *buf, int len)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    struct server *server = ss_malloc(sizeof(struct server));\n", "    memset(server, 0, sizeof(struct server));\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (strcmp(name, \"server_port\") == 0) {\n", "                if (value->type == json_string) {\n", "else\n", "else\n", "            } else if (strcmp(name, \"password\") == 0) {\n", "                if (value->type == json_string) {\n", "                    strncpy(server->password, value->u.string.ptr, 128);\n", "else\n", "            } else if (strcmp(name, \"method\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->method = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"fast_open\") == 0) {\n", "                if (value->type == json_boolean) {\n", "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n", "else\n", "            } else if (strcmp(name, \"plugin\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->plugin_opts = strdup(value->u.string.ptr);\n", "else\n", "            } else if (strcmp(name, \"mode\") == 0) {\n", "                if (value->type == json_string) {\n", "                    server->mode = strdup(value->u.string.ptr);\n", "    return server;\n"]}, {"FileName": "manager.c", "Caller": "parse_traffic", "Source": false, "Sink": false, "idx": 63, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 325, "label": -3, "slices": ["parse_traffic(char *buf, int len, char *port, uint64_t *traffic)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "        LOGE(\"%s\", error_buf);\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (value->type == json_integer) {\n", "                strncpy(port, name, 8);\n", "                *traffic = value->u.integer;\n", "    json_value_free(obj);\n"]}, {"FileName": "manager.c", "Caller": "parse_traffic", "Source": false, "Sink": false, "idx": 64, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strncpy", "line": 337, "label": -3, "slices": ["parse_traffic(char *buf, int len, char *port, uint64_t *traffic)\n", "    char *data = get_data(buf, len);\n", "    char error_buf[512];\n", "    if (data == NULL) {\n", "    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);\n", "    if (obj == NULL) {\n", "    if (obj->type == json_object) {\n", "        int i = 0;\n", "        for (i = 0; i < obj->u.object.length; i++) {\n", "            char *name        = obj->u.object.values[i].name;\n", "            json_value *value = obj->u.object.values[i].value;\n", "            if (value->type == json_integer) {\n", "                strncpy(port, name, 8);\n"]}, {"FileName": "manager.c", "Caller": "create_and_bind", "Source": false, "Sink": false, "idx": 65, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 354, "label": -3, "slices": ["    memset(&hints, 0, sizeof(struct addrinfo));\n"]}, {"FileName": "manager.c", "Caller": "create_and_bind", "Source": false, "Sink": false, "idx": 66, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "getaddrinfo", "line": 361, "label": -3, "slices": ["create_and_bind(const char *host, const char *port, int protocol)\n", "    struct addrinfo *result, *rp, *ipv4v6bindall;\n", "    int s, listen_sock = -1;\n", "    s = getaddrinfo(host, port, &hints, &result);\n", "    if (s != 0) {\n", "        LOGE(\"getaddrinfo: %s\", gai_strerror(s));\n", "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n", "        if (listen_sock == -1) {\n", "        if (rp->ai_family == AF_INET6) {\n", "            int ipv6only = host ? 1 : 0;\n", "        if (s == 0) {\n"]}, {"FileName": "manager.c", "Caller": "create_and_bind", "Source": false, "Sink": false, "idx": 67, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "socket", "line": 390, "label": -3, "slices": ["    struct addrinfo *result, *rp, *ipv4v6bindall;\n", "    int s, listen_sock = -1;\n", "    if (s != 0) {\n", "    rp = result;\n", "    if (!host) {\n", "        ipv4v6bindall = result;\n", "        while (ipv4v6bindall) {\n", "            if (ipv4v6bindall->ai_family == AF_INET6) {\n", "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n", "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n", "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n", "        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n", "        if (listen_sock == -1) {\n", "        if (rp->ai_family == AF_INET6) {\n", "            int ipv6only = host ? 1 : 0;\n", "            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n", "        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n", "        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n", "        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n", "        if (s == 0) {\n", "            close(listen_sock);\n", "    if (rp == NULL) {\n", "    return listen_sock;\n"]}, {"FileName": "manager.c", "Caller": "create_and_bind", "Source": false, "Sink": false, "idx": 68, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "close", "line": 410, "label": -3, "slices": ["    struct addrinfo *result, *rp, *ipv4v6bindall;\n", "    int s, listen_sock = -1;\n", "    if (s != 0) {\n", "    rp = result;\n", "    if (!host) {\n", "        ipv4v6bindall = result;\n", "        while (ipv4v6bindall) {\n", "            if (ipv4v6bindall->ai_family == AF_INET6) {\n", "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n", "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n", "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n", "        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n", "        if (listen_sock == -1) {\n", "        if (rp->ai_family == AF_INET6) {\n", "            int ipv6only = host ? 1 : 0;\n", "            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n", "        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n", "        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n", "        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n", "        if (s == 0) {\n", "            close(listen_sock);\n", "    if (rp == NULL) {\n", "    return listen_sock;\n"]}, {"FileName": "manager.c", "Caller": "check_port", "Source": false, "Sink": false, "idx": 69, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 438, "label": -3, "slices": ["check_port(struct manager_ctx *manager, struct server *server)\n", "    bool both_tcp_udp = manager->mode == TCP_AND_UDP;\n", "    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);\n", "    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));\n", "    memset(sock_fds, 0, fd_count * sizeof(int));\n", "    for (int i = 0; i < manager->host_num; i++) {\n", "        if (manager->mode == UDP_ONLY) {\n", "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n", "else\n", "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);\n", "        if (both_tcp_udp) {\n", "            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n", "        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {\n", "    for (int i = 0; i < fd_count; i++) {\n", "        if (sock_fds[i] > 0) {\n", "            close(sock_fds[i]);\n", "    ss_free(sock_fds);\n"]}, {"FileName": "manager.c", "Caller": "check_port", "Source": false, "Sink": false, "idx": 70, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "close", "line": 463, "label": -3, "slices": ["check_port(struct manager_ctx *manager, struct server *server)\n", "    bool both_tcp_udp = manager->mode == TCP_AND_UDP;\n", "    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);\n", "    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));\n", "    memset(sock_fds, 0, fd_count * sizeof(int));\n", "    for (int i = 0; i < manager->host_num; i++) {\n", "        LOGI(\"try to bind interface: %s, port: %s\", manager->hosts[i], server->port);\n", "        if (manager->mode == UDP_ONLY) {\n", "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n", "else\n", "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);\n", "        if (both_tcp_udp) {\n", "            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n", "        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {\n", "    for (int i = 0; i < fd_count; i++) {\n", "        if (sock_fds[i] > 0) {\n", "            close(sock_fds[i]);\n", "    ss_free(sock_fds);\n"]}, {"FileName": "manager.c", "Caller": "add_server", "Source": false, "Sink": false, "idx": 71, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "system", "line": 486, "label": -3, "slices": ["add_server(struct manager_ctx *manager, struct server *server)\n", "    int ret = check_port(manager, server);\n", "    if (ret == -1) {\n", "    char *cmd = construct_command_line(manager, server);\n"]}, {"FileName": "manager.c", "Caller": "kill_server", "Source": false, "Sink": false, "idx": 72, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 498, "label": -3, "slices": ["kill_server(char *prefix, char *pid_file)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    if (fscanf(f, \"%d\", &pid) != EOF) {\n", "        kill(pid, SIGTERM);\n", "    fclose(f);\n", "    remove(path);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "kill_server", "Source": false, "Sink": false, "idx": 73, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 498, "label": -3, "slices": ["kill_server(char *prefix, char *pid_file)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    if (fscanf(f, \"%d\", &pid) != EOF) {\n", "        kill(pid, SIGTERM);\n", "    fclose(f);\n", "    remove(path);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "kill_server", "Source": false, "Sink": false, "idx": 74, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 500, "label": -3, "slices": ["kill_server(char *prefix, char *pid_file)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    remove(path);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "kill_server", "Source": false, "Sink": false, "idx": 75, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fopen", "line": 501, "label": -3, "slices": ["kill_server(char *prefix, char *pid_file)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    fclose(f);\n", "    remove(path);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "kill_server", "Source": false, "Sink": false, "idx": 76, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fscanf", "line": 509, "label": -3, "slices": ["kill_server(char *prefix, char *pid_file)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n", "    path = ss_malloc(path_size);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "kill_server", "Source": false, "Sink": false, "idx": 77, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fclose", "line": 512, "label": -3, "slices": ["kill_server(char *prefix, char *pid_file)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n", "    path = ss_malloc(path_size);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "kill_server", "Source": false, "Sink": false, "idx": 78, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "remove", "line": 513, "label": -3, "slices": ["kill_server(char *prefix, char *pid_file)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    remove(path);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "stop_server", "Source": false, "Sink": false, "idx": 79, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 521, "label": -3, "slices": ["stop_server(char *prefix, char *port)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    if (fscanf(f, \"%d\", &pid) != EOF) {\n", "        kill(pid, SIGTERM);\n", "    fclose(f);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "stop_server", "Source": false, "Sink": false, "idx": 80, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 521, "label": -3, "slices": ["stop_server(char *prefix, char *port)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    if (fscanf(f, \"%d\", &pid) != EOF) {\n", "        kill(pid, SIGTERM);\n", "    fclose(f);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "stop_server", "Source": false, "Sink": false, "idx": 81, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 523, "label": -3, "slices": ["stop_server(char *prefix, char *port)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "stop_server", "Source": false, "Sink": false, "idx": 82, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fopen", "line": 524, "label": -3, "slices": ["stop_server(char *prefix, char *port)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n", "    path = ss_malloc(path_size);\n", "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "        ss_free(path);\n", "    fclose(f);\n", "    ss_free(path);\n"]}, {"FileName": "manager.c", "Caller": "stop_server", "Source": false, "Sink": false, "idx": 83, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fscanf", "line": 532, "label": -3, "slices": ["stop_server(char *prefix, char *port)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n", "    path = ss_malloc(path_size);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "stop_server", "Source": false, "Sink": false, "idx": 84, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fclose", "line": 535, "label": -3, "slices": ["stop_server(char *prefix, char *port)\n", "    char *path = NULL;\n", "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n", "    path = ss_malloc(path_size);\n", "    FILE *f = fopen(path, \"r\");\n", "    if (f == NULL) {\n", "    fclose(f);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 85, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 577, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    memset(buf, 0, BUF_SIZE);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "        char port[8];\n", "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n", "    strcpy(buf, \"err\");\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 86, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "recvfrom", "line": 580, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    memset(buf, 0, BUF_SIZE);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "        LOGE(\"too large request: %d\", (int)r);\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "            if (server != NULL) {\n", "                destroy_server(server);\n", "                ss_free(server);\n", "        remove_server(working_dir, server->port);\n", "        int ret = add_server(manager, server);\n", "        char *msg;\n", "        int msg_len;\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "            if (server != NULL) {\n", "                destroy_server(server);\n", "                ss_free(server);\n", "        remove_server(working_dir, server->port);\n", "        destroy_server(server);\n", "        ss_free(server);\n", "        char msg[3] = \"ok\";\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "        char port[8];\n", "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "        size_t pos = strlen(buf);\n", "    strcpy(buf, \"err\");\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 87, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 596, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 88, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sendto", "line": 622, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    len = sizeof(struct sockaddr_un);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "        int ret = add_server(manager, server);\n", "        char *msg;\n", "        int msg_len;\n", "        if (ret == -1) {\n", "            msg     = \"port is not available\";\n", "            msg_len = 21;\n", "else\n", "            msg     = \"ok\";\n", "            msg_len = 2;\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "        char msg[3] = \"ok\";\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 89, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 625, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 90, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 629, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 91, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sprintf", "line": 630, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 92, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 636, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 93, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 637, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 94, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 637, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 95, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 637, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 96, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sendto", "line": 639, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    len = sizeof(struct sockaddr_un);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "        int ret = add_server(manager, server);\n", "        char *msg;\n", "        int msg_len;\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "        char msg[3] = \"ok\";\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 97, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 643, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 98, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sprintf", "line": 646, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "                pos = 0;\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 99, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 651, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 100, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcpy", "line": 652, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 101, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 653, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "        struct server *server = get_server(buf, r);\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 102, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sendto", "line": 654, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    len = sizeof(struct sockaddr_un);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "        int ret = add_server(manager, server);\n", "        char *msg;\n", "        int msg_len;\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"[\");\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "                memset(buf, 0, BUF_SIZE);\n", "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n", "        size_t pos = strlen(buf);\n", "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n", "        pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "        char msg[3] = \"ok\";\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 103, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 658, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 104, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sendto", "line": 675, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    len = sizeof(struct sockaddr_un);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "        int ret = add_server(manager, server);\n", "        char *msg;\n", "        int msg_len;\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "        char msg[3] = \"ok\";\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 105, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 678, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 106, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 688, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 107, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 694, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"stat: {\");\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "                buf[pos - 1] = '}';\n", "                memset(buf, 0, BUF_SIZE);\n", "        size_t pos = strlen(buf);\n", "        if (pos > 7) {\n", "            buf[pos - 1] = '}';\n", "else\n", "            buf[pos] = '}';\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 108, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sprintf", "line": 695, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"stat: {\");\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "                buf[pos - 1] = '}';\n", "                memset(buf, 0, BUF_SIZE);\n", "        size_t pos = strlen(buf);\n", "        if (pos > 7) {\n", "            buf[pos - 1] = '}';\n", "else\n", "            buf[pos] = '}';\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 109, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 701, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"stat: {\");\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "                buf[pos - 1] = '}';\n", "                memset(buf, 0, BUF_SIZE);\n", "        size_t pos = strlen(buf);\n", "        if (pos > 7) {\n", "            buf[pos - 1] = '}';\n", "else\n", "            buf[pos] = '}';\n", "            pos++;\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 110, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sendto", "line": 704, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    len = sizeof(struct sockaddr_un);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "        int ret = add_server(manager, server);\n", "        char *msg;\n", "        int msg_len;\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "        char msg[3] = \"ok\";\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"stat: {\");\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "                buf[pos - 1] = '}';\n", "                memset(buf, 0, BUF_SIZE);\n", "        size_t pos = strlen(buf);\n", "        if (pos > 7) {\n", "            buf[pos - 1] = '}';\n", "else\n", "            buf[pos] = '}';\n", "            pos++;\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 111, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 708, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"stat: {\");\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "                buf[pos - 1] = '}';\n", "                memset(buf, 0, BUF_SIZE);\n", "        size_t pos = strlen(buf);\n", "        if (pos > 7) {\n", "            buf[pos - 1] = '}';\n", "else\n", "            buf[pos] = '}';\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 112, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 714, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"stat: {\");\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "                buf[pos - 1] = '}';\n", "                memset(buf, 0, BUF_SIZE);\n", "        size_t pos = strlen(buf);\n", "        if (pos > 7) {\n", "            buf[pos - 1] = '}';\n", "else\n", "            buf[pos] = '}';\n", "            pos++;\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 113, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sendto", "line": 722, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    len = sizeof(struct sockaddr_un);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "        int ret = add_server(manager, server);\n", "        char *msg;\n", "        int msg_len;\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "        char msg[3] = \"ok\";\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        memset(buf, 0, BUF_SIZE);\n", "        sprintf(buf, \"stat: {\");\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "                buf[pos - 1] = '}';\n", "                memset(buf, 0, BUF_SIZE);\n", "        size_t pos = strlen(buf);\n", "        if (pos > 7) {\n", "            buf[pos - 1] = '}';\n", "else\n", "            buf[pos] = '}';\n", "            pos++;\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 114, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcpy", "line": 731, "label": -3, "slices": ["    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    memset(buf, 0, BUF_SIZE);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "        int ret = add_server(manager, server);\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "        char port[8];\n", "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "        char buf[BUF_SIZE];\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "        size_t pos = strlen(buf);\n", "    strcpy(buf, \"err\");\n"]}, {"FileName": "manager.c", "Caller": "manager_recv_cb", "Source": false, "Sink": false, "idx": 115, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "sendto", "line": 732, "label": -3, "slices": ["manager_recv_cb(EV_P_ ev_io *w, int revents)\n", "    struct manager_ctx *manager = (struct manager_ctx *)w;\n", "    socklen_t len;\n", "    ssize_t r;\n", "    char buf[BUF_SIZE];\n", "    memset(buf, 0, BUF_SIZE);\n", "    len = sizeof(struct sockaddr_un);\n", "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n", "    if (r == -1) {\n", "    if (r > BUF_SIZE / 2) {\n", "    char *action = get_action(buf, r);\n", "    if (action == NULL) {\n", "    if (strcmp(action, \"add\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "        int ret = add_server(manager, server);\n", "        char *msg;\n", "        int msg_len;\n", "else\n", "    } else if (strcmp(action, \"list\") == 0) {\n", "        struct cork_hash_table_entry  *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            char *method = server->method?server->method:manager->method;\n", "            size_t pos = strlen(buf);\n", "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n", "            if (pos > BUF_SIZE-entry_len-50) {\n", "        size_t pos = strlen(buf);\n", "else\n", "    } else if (strcmp(action, \"remove\") == 0) {\n", "        struct server *server = get_server(buf, r);\n", "        if (server == NULL || server->port[0] == 0) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "        char msg[3] = \"ok\";\n", "else\n", "    } else if (strcmp(action, \"stat\") == 0) {\n", "        char port[8];\n", "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n", "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n", "else\n", "    } else if (strcmp(action, \"ping\") == 0) {\n", "        struct cork_hash_table_entry *entry;\n", "        char buf[BUF_SIZE];\n", "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "            struct server *server = (struct server *)entry->value;\n", "            size_t pos            = strlen(buf);\n", "            if (pos > BUF_SIZE / 2) {\n", "        size_t pos = strlen(buf);\n", "    strcpy(buf, \"err\");\n"]}, {"FileName": "manager.c", "Caller": "create_server_socket", "Source": false, "Sink": false, "idx": 116, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 756, "label": -3, "slices": ["    memset(&hints, 0, sizeof(struct addrinfo));\n"]}, {"FileName": "manager.c", "Caller": "create_server_socket", "Source": false, "Sink": false, "idx": 117, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "getaddrinfo", "line": 762, "label": -3, "slices": ["create_server_socket(const char *host, const char *port)\n", "    struct addrinfo *result, *rp, *ipv4v6bindall;\n", "    int s, server_sock;\n", "    s = getaddrinfo(host, port, &hints, &result);\n", "    if (s != 0) {\n", "        LOGE(\"getaddrinfo: %s\", gai_strerror(s));\n", "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n", "        if (server_sock == -1) {\n", "        if (rp->ai_family == AF_INET6) {\n", "            int ipv6only = host ? 1 : 0;\n", "        if (s == 0) {\n"]}, {"FileName": "manager.c", "Caller": "create_server_socket", "Source": false, "Sink": false, "idx": 118, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "socket", "line": 790, "label": -3, "slices": ["    struct addrinfo *result, *rp, *ipv4v6bindall;\n", "    int s, server_sock;\n", "    if (s != 0) {\n", "    rp = result;\n", "    if (!host) {\n", "        ipv4v6bindall = result;\n", "        while (ipv4v6bindall) {\n", "            if (ipv4v6bindall->ai_family == AF_INET6) {\n", "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n", "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n", "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n", "        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n", "        if (server_sock == -1) {\n", "        if (rp->ai_family == AF_INET6) {\n", "            int ipv6only = host ? 1 : 0;\n", "            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n", "        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n", "        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);\n", "        if (s == 0) {\n", "        close(server_sock);\n", "    if (rp == NULL) {\n", "    return server_sock;\n"]}, {"FileName": "manager.c", "Caller": "create_server_socket", "Source": false, "Sink": false, "idx": 119, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "close", "line": 811, "label": -3, "slices": ["    struct addrinfo *result, *rp, *ipv4v6bindall;\n", "    int s, server_sock;\n", "    if (s != 0) {\n", "    rp = result;\n", "    if (!host) {\n", "        ipv4v6bindall = result;\n", "        while (ipv4v6bindall) {\n", "            if (ipv4v6bindall->ai_family == AF_INET6) {\n", "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n", "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n", "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n", "        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n", "        if (server_sock == -1) {\n", "        if (rp->ai_family == AF_INET6) {\n", "            int ipv6only = host ? 1 : 0;\n", "            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n", "        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n", "        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);\n", "        if (s == 0) {\n", "        close(server_sock);\n", "    if (rp == NULL) {\n", "    return server_sock;\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 120, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "getopt_long", "line": 879, "label": -3, "slices": ["main(int argc, char **argv)\n", "    int i, c;\n", "    int pid_flags         = 0;\n", "    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    int server_num = 0;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n", "    if (conf_path != NULL) {\n", "    USE_SYSLOG(argv[0], pid_flags);\n", "    DIR *dp;\n", "    struct dirent *ep;\n", "    if (dp != NULL) {\n", "        while ((ep = readdir(dp)) != NULL) {\n", "            size_t len = strlen(ep->d_name);\n", "    struct cork_hash_table_entry *entry;\n", "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "        struct server *server = (struct server *)entry->value;\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 121, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "atoi", "line": 898, "label": -3, "slices": ["    int i, c;\n", "    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    int mtu        = 0;\n", "    int ipv6first  = 0;\n", "    static int nofile = 0;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n", "        switch (c) {\n", "            mtu = atoi(optarg);\n", "    if (conf_path != NULL) {\n", "    struct manager_ctx manager;\n", "    manager.mtu             = mtu;\n", "    manager.plugin          = plugin;\n", "    manager.plugin_opts     = plugin_opts;\n", "    manager.ipv6first       = ipv6first;\n", "    manager.nofile = nofile;\n", "    struct ev_loop *loop = EV_DEFAULT;\n", "    int sfd;\n", "    manager.fd = sfd;\n", "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n", "    ev_io_start(loop, &manager.io);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 122, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "atoi", "line": 957, "label": -3, "slices": ["    int i, c;\n", "    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    static int nofile = 0;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n", "        switch (c) {\n", "            nofile = atoi(optarg);\n", "    if (conf_path != NULL) {\n", "    struct manager_ctx manager;\n", "    manager.nofile = nofile;\n", "    struct ev_loop *loop = EV_DEFAULT;\n", "    int sfd;\n", "    manager.fd = sfd;\n", "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n", "    ev_io_start(loop, &manager.io);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 123, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "signal", "line": 1061, "label": -3, "slices": ["    signal(SIGPIPE, SIG_IGN);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 124, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "signal", "line": 1062, "label": -3, "slices": ["    signal(SIGCHLD, SIG_IGN);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 125, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "signal", "line": 1063, "label": -3, "slices": ["    signal(SIGABRT, SIG_IGN);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 126, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 1073, "label": -3, "slices": ["    memset(&manager, 0, sizeof(struct manager_ctx));\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 127, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "getpwuid", "line": 1105, "label": -3, "slices": ["    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    struct passwd *pw   = getpwuid(getuid());\n", "    const char *homedir = pw->pw_dir;\n", "    working_dir_size = strlen(homedir) + 15;\n", "    working_dir      = ss_malloc(working_dir_size);\n", "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n", "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n", "    if (err != 0 && errno != EEXIST) {\n", "        ss_free(working_dir);\n", "    DIR *dp;\n", "    struct dirent *ep;\n", "    dp = opendir(working_dir);\n", "    if (dp != NULL) {\n", "        while ((ep = readdir(dp)) != NULL) {\n", "            size_t len = strlen(ep->d_name);\n", "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n", "                kill_server(working_dir, ep->d_name);\n", "                if (verbose)\n", "                    LOGI(\"kill %s\", ep->d_name);\n", "        closedir(dp);\n", "else\n", "        ss_free(working_dir);\n", "            struct server *server = ss_malloc(sizeof(struct server));\n", "    int sfd;\n", "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n", "        if (sfd == -1) {\n", "            ss_free(working_dir);\n", "        if (remove(manager_address) == -1 && errno != ENOENT) {\n", "            ss_free(working_dir);\n", "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n", "            ss_free(working_dir);\n", "        if (sfd == -1) {\n", "            ss_free(working_dir);\n", "    struct cork_hash_table_entry *entry;\n", "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "        struct server *server = (struct server *)entry->value;\n", "        stop_server(working_dir, server->port);\n", "    ss_free(working_dir);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 128, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1107, "label": -3, "slices": ["    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    struct passwd *pw   = getpwuid(getuid());\n", "    const char *homedir = pw->pw_dir;\n", "    working_dir_size = strlen(homedir) + 15;\n", "    working_dir      = ss_malloc(working_dir_size);\n", "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n", "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n", "    if (err != 0 && errno != EEXIST) {\n", "        ss_free(working_dir);\n", "    DIR *dp;\n", "    struct dirent *ep;\n", "    dp = opendir(working_dir);\n", "    if (dp != NULL) {\n", "        while ((ep = readdir(dp)) != NULL) {\n", "            size_t len = strlen(ep->d_name);\n", "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n", "                kill_server(working_dir, ep->d_name);\n", "                if (verbose)\n", "                    LOGI(\"kill %s\", ep->d_name);\n", "        closedir(dp);\n", "else\n", "        ss_free(working_dir);\n", "            struct server *server = ss_malloc(sizeof(struct server));\n", "    int sfd;\n", "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n", "        if (sfd == -1) {\n", "            ss_free(working_dir);\n", "        if (remove(manager_address) == -1 && errno != ENOENT) {\n", "            ss_free(working_dir);\n", "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n", "            ss_free(working_dir);\n", "        if (sfd == -1) {\n", "            ss_free(working_dir);\n", "    struct cork_hash_table_entry *entry;\n", "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "        struct server *server = (struct server *)entry->value;\n", "        stop_server(working_dir, server->port);\n", "    ss_free(working_dir);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 129, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "snprintf", "line": 1109, "label": -3, "slices": ["    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    struct passwd *pw   = getpwuid(getuid());\n", "    const char *homedir = pw->pw_dir;\n", "    working_dir_size = strlen(homedir) + 15;\n", "    working_dir      = ss_malloc(working_dir_size);\n", "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n", "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n", "    if (err != 0 && errno != EEXIST) {\n", "        ss_free(working_dir);\n", "    DIR *dp;\n", "    struct dirent *ep;\n", "    dp = opendir(working_dir);\n", "    if (dp != NULL) {\n", "        while ((ep = readdir(dp)) != NULL) {\n", "            size_t len = strlen(ep->d_name);\n", "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n", "                kill_server(working_dir, ep->d_name);\n", "else\n", "        ss_free(working_dir);\n", "            struct server *server = ss_malloc(sizeof(struct server));\n", "    int sfd;\n", "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n", "        if (sfd == -1) {\n", "            ss_free(working_dir);\n", "        if (remove(manager_address) == -1 && errno != ENOENT) {\n", "            ss_free(working_dir);\n", "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n", "            ss_free(working_dir);\n", "        if (sfd == -1) {\n", "            ss_free(working_dir);\n", "    struct cork_hash_table_entry *entry;\n", "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "        struct server *server = (struct server *)entry->value;\n", "        stop_server(working_dir, server->port);\n", "    ss_free(working_dir);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 130, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "mkdir", "line": 1111, "label": -3, "slices": ["    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    struct passwd *pw   = getpwuid(getuid());\n", "    const char *homedir = pw->pw_dir;\n", "    working_dir_size = strlen(homedir) + 15;\n", "    working_dir      = ss_malloc(working_dir_size);\n", "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n", "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n", "    if (err != 0 && errno != EEXIST) {\n", "        ss_free(working_dir);\n", "    DIR *dp;\n", "    struct dirent *ep;\n", "    dp = opendir(working_dir);\n", "    if (dp != NULL) {\n", "        while ((ep = readdir(dp)) != NULL) {\n", "            size_t len = strlen(ep->d_name);\n", "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n", "                kill_server(working_dir, ep->d_name);\n", "else\n", "        ss_free(working_dir);\n", "            struct server *server = ss_malloc(sizeof(struct server));\n", "    int sfd;\n", "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n", "        if (sfd == -1) {\n", "            ss_free(working_dir);\n", "        if (remove(manager_address) == -1 && errno != ENOENT) {\n", "            ss_free(working_dir);\n", "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n", "            ss_free(working_dir);\n", "        if (sfd == -1) {\n", "            ss_free(working_dir);\n", "    struct cork_hash_table_entry *entry;\n", "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n", "        struct server *server = (struct server *)entry->value;\n", "        stop_server(working_dir, server->port);\n", "    ss_free(working_dir);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 131, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1124, "label": -3, "slices": ["    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    struct passwd *pw   = getpwuid(getuid());\n", "    const char *homedir = pw->pw_dir;\n", "    working_dir_size = strlen(homedir) + 15;\n", "    working_dir      = ss_malloc(working_dir_size);\n", "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n", "    DIR *dp;\n", "    struct dirent *ep;\n", "    dp = opendir(working_dir);\n", "    if (dp != NULL) {\n", "        while ((ep = readdir(dp)) != NULL) {\n", "            size_t len = strlen(ep->d_name);\n", "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n", "                kill_server(working_dir, ep->d_name);\n", "                if (verbose)\n", "                    LOGI(\"kill %s\", ep->d_name);\n", "            struct server *server = ss_malloc(sizeof(struct server));\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 132, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 1125, "label": -3, "slices": ["    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    struct passwd *pw   = getpwuid(getuid());\n", "    const char *homedir = pw->pw_dir;\n", "    working_dir_size = strlen(homedir) + 15;\n", "    working_dir      = ss_malloc(working_dir_size);\n", "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n", "    DIR *dp;\n", "    struct dirent *ep;\n", "    dp = opendir(working_dir);\n", "    if (dp != NULL) {\n", "        while ((ep = readdir(dp)) != NULL) {\n", "            size_t len = strlen(ep->d_name);\n", "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n", "                kill_server(working_dir, ep->d_name);\n", "                if (verbose)\n", "                    LOGI(\"kill %s\", ep->d_name);\n", "            struct server *server = ss_malloc(sizeof(struct server));\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 133, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 1142, "label": -3, "slices": ["    int i, c;\n", "    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    if (conf != NULL) {\n", "        for (i = 0; i < conf->port_password_num; i++) {\n", "            struct server *server = ss_malloc(sizeof(struct server));\n", "            memset(server, 0, sizeof(struct server));\n", "            strncpy(server->port, conf->port_password[i].port, 8);\n", "            strncpy(server->password, conf->port_password[i].password, 128);\n", "            add_server(&manager, server);\n", "        struct server *server = (struct server *)entry->value;\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 134, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strncpy", "line": 1143, "label": -3, "slices": ["    int i, c;\n", "    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    int fast_open  = 0;\n", "    int reuse_port = 0;\n", "    int mode       = TCP_ONLY;\n", "    int mtu        = 0;\n", "    int ipv6first  = 0;\n", "    static int nofile = 0;\n", "    int server_num = 0;\n", "    char *server_host[MAX_REMOTE_NUM];\n", "    char *nameservers[MAX_DNS_NUM + 1];\n", "    int nameserver_num = 0;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n", "        switch (c) {\n", "            conf_path = optarg;\n", "    if (conf_path != NULL) {\n", "        conf = read_jconf(conf_path);\n", "        if (server_num == 0) {\n", "            server_num = conf->remote_num;\n", "            for (i = 0; i < server_num; i++)\n", "                server_host[i] = conf->remote_addr[i].host;\n", "        if (password == NULL) {\n", "            password = conf->password;\n", "        if (method == NULL) {\n", "            method = conf->method;\n", "        if (timeout == NULL) {\n", "            timeout = conf->timeout;\n", "        if (user == NULL) {\n", "            user = conf->user;\n", "        if (fast_open == 0) {\n", "            fast_open = conf->fast_open;\n", "        if (reuse_port == 0) {\n", "            reuse_port = conf->reuse_port;\n", "        if (conf->nameserver != NULL) {\n", "            nameservers[nameserver_num++] = conf->nameserver;\n", "        if (mode == TCP_ONLY) {\n", "            mode = conf->mode;\n", "        if (mtu == 0) {\n", "            mtu = conf->mtu;\n", "        if (plugin == NULL) {\n", "            plugin = conf->plugin;\n", "        if (plugin_opts == NULL) {\n", "            plugin_opts = conf->plugin_opts;\n", "        if (ipv6first == 0) {\n", "            ipv6first = conf->ipv6_first;\n", "        if (nofile == 0) {\n", "            nofile = conf->nofile;\n", "    if (conf != NULL) {\n", "        for (i = 0; i < conf->port_password_num; i++) {\n", "            struct server *server = ss_malloc(sizeof(struct server));\n", "            memset(server, 0, sizeof(struct server));\n", "            strncpy(server->port, conf->port_password[i].port, 8);\n", "            strncpy(server->password, conf->port_password[i].password, 128);\n", "            add_server(&manager, server);\n", "        struct server *server = (struct server *)entry->value;\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 135, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strncpy", "line": 1144, "label": -3, "slices": ["    int i, c;\n", "    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    int fast_open  = 0;\n", "    int reuse_port = 0;\n", "    int mode       = TCP_ONLY;\n", "    int mtu        = 0;\n", "    int ipv6first  = 0;\n", "    static int nofile = 0;\n", "    int server_num = 0;\n", "    char *server_host[MAX_REMOTE_NUM];\n", "    char *nameservers[MAX_DNS_NUM + 1];\n", "    int nameserver_num = 0;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n", "        switch (c) {\n", "            conf_path = optarg;\n", "    if (conf_path != NULL) {\n", "        conf = read_jconf(conf_path);\n", "        if (server_num == 0) {\n", "            server_num = conf->remote_num;\n", "            for (i = 0; i < server_num; i++)\n", "                server_host[i] = conf->remote_addr[i].host;\n", "        if (password == NULL) {\n", "            password = conf->password;\n", "        if (method == NULL) {\n", "            method = conf->method;\n", "        if (timeout == NULL) {\n", "            timeout = conf->timeout;\n", "        if (user == NULL) {\n", "            user = conf->user;\n", "        if (fast_open == 0) {\n", "            fast_open = conf->fast_open;\n", "        if (reuse_port == 0) {\n", "            reuse_port = conf->reuse_port;\n", "        if (conf->nameserver != NULL) {\n", "            nameservers[nameserver_num++] = conf->nameserver;\n", "        if (mode == TCP_ONLY) {\n", "            mode = conf->mode;\n", "        if (mtu == 0) {\n", "            mtu = conf->mtu;\n", "        if (plugin == NULL) {\n", "            plugin = conf->plugin;\n", "        if (plugin_opts == NULL) {\n", "            plugin_opts = conf->plugin_opts;\n", "        if (ipv6first == 0) {\n", "            ipv6first = conf->ipv6_first;\n", "        if (nofile == 0) {\n", "            nofile = conf->nofile;\n", "    if (conf != NULL) {\n", "        for (i = 0; i < conf->port_password_num; i++) {\n", "            struct server *server = ss_malloc(sizeof(struct server));\n", "            memset(server, 0, sizeof(struct server));\n", "            strncpy(server->port, conf->port_password[i].port, 8);\n", "            strncpy(server->password, conf->port_password[i].password, 128);\n", "            add_server(&manager, server);\n", "        struct server *server = (struct server *)entry->value;\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 136, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "socket", "line": 1155, "label": -3, "slices": ["    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    struct manager_ctx manager;\n", "    struct ev_loop *loop = EV_DEFAULT;\n", "    int sfd;\n", "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n", "        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);       /*  Create server socket */\n", "        setnonblocking(sfd);\n", "    manager.fd = sfd;\n", "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n", "    ev_io_start(loop, &manager.io);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 137, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "remove", "line": 1163, "label": -3, "slices": ["    int i, c;\n", "    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    int server_num = 0;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n", "        switch (c) {\n", "            manager_address = optarg;\n", "    if (manager_address == NULL) {\n", "        manager_address = \"127.0.0.1:8839\";\n", "        LOGI(\"using the default manager address: %s\", manager_address);\n", "    struct manager_ctx manager;\n", "    manager.manager_address = manager_address;\n", "    parse_addr(manager_address, &ip_addr);\n", "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n", "        struct sockaddr_un svaddr;\n", "        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 138, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 1169, "label": -3, "slices": ["    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n", "        memset(&svaddr, 0, sizeof(struct sockaddr_un));\n"]}, {"FileName": "manager.c", "Caller": "main", "Source": false, "Sink": false, "idx": 139, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strncpy", "line": 1171, "label": -3, "slices": ["    int i, c;\n", "    char *acl             = NULL;\n", "    char *user            = NULL;\n", "    char *password        = NULL;\n", "    char *timeout         = NULL;\n", "    char *method          = NULL;\n", "    char *pid_path        = NULL;\n", "    char *conf_path       = NULL;\n", "    char *iface           = NULL;\n", "    char *manager_address = NULL;\n", "    char *plugin          = NULL;\n", "    char *plugin_opts     = NULL;\n", "    int server_num = 0;\n", "    jconf_t *conf = NULL;\n", "    static struct option long_options[] = {\n", "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n", "        switch (c) {\n", "            manager_address = optarg;\n", "    if (manager_address == NULL) {\n", "        manager_address = \"127.0.0.1:8839\";\n", "        LOGI(\"using the default manager address: %s\", manager_address);\n", "    struct manager_ctx manager;\n", "    manager.manager_address = manager_address;\n", "    parse_addr(manager_address, &ip_addr);\n", "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n", "        struct sockaddr_un svaddr;\n", "        svaddr.sun_family = AF_UNIX;\n", "        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);\n"]}]