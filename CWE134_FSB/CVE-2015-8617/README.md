# ğŸ“ CVE-2015-8617

## ğŸ” ì·¨ì•½ì  ê°œìš”

**ğŸ”— [ì»¤ë°‹ ë§í¬](https://github.com/php/php-src/commit/b101a6bbd4f2181c360bd38e7683df4a03cba83e)** | **ğŸ”— [CVE ë§í¬](https://www.cvedetails.com/cve/CVE-2015-8617)**  | **ğŸ”— [CWE ë§í¬](https://cwe.mitre.org/data/definitions/134.html)** 

> PHP 7.0.1 ì´ì „ ë²„ì „ì˜ `Zend/zend_execute_API.c`ì˜ `zend_throw_or_error` í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì™¸ë¶€ ì…ë ¥ì„ ë¬¸ìì—´ ë©”ì‹œì§€ë¡œ í¬ë§·íŒ…í•œ í›„, `zend_throw_error()`ë¥¼ í†µí•´ í¬ë§· ë¬¸ìì—´ í•´ì„ì´ ì´ë£¨ì–´ì§€ëŠ” ë°©ì‹ì—ì„œ ë°œìƒí•˜ëŠ” \*\*í˜•ì‹ ë¬¸ìì—´ ì·¨ì•½ì (CWE-134)\*\*ì…ë‹ˆë‹¤. ê³µê²©ìê°€ í¬ë§· ë¬¸ìì—´ì„ ì¡°ì‘í•˜ì—¬ ì„ì˜ ì½”ë“œ ì‹¤í–‰ì´ë‚˜ ë¹„ì •ìƒ ë™ì‘ì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* **Source**: ì™¸ë¶€ì—ì„œ ì œì–´ ê°€ëŠ¥í•œ ìƒìˆ˜ ì´ë¦„(ì˜ˆ: í´ë˜ìŠ¤ëª… ë¬¸ìì—´)
* **ì·¨ì•½ ì¡°ê±´**: ìƒìˆ˜ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ë•Œ ì˜ˆì™¸ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ë©° í¬ë§· ë¬¸ìì—´ì— ìœ ì…ë¨
* **Sink**: `zend_throw_error()` â€“ í¬ë§· ë¬¸ìì—´ì´ ì‹¤ì œë¡œ í•´ì„ë˜ëŠ” í•¨ìˆ˜

---

## íƒì§€ ê²°ê³¼ ìš”ì•½

| ì´ ìŠ¬ë¼ì´ìŠ¤ ìˆ˜ | ì·¨ì•½ìœ¼ë¡œ íƒì§€ | ì •ìƒìœ¼ë¡œ íƒì§€ |
| -------- | ------- | ------- |
| 0ê°œ      | 0ê°œ      | 0ê°œ     |

\* Sink(`end_throw_error` í•¨ìˆ˜) ê´€ë ¨ ìŠ¬ë¼ì´ìŠ¤ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŒ


ì´ CVE ì·¨ì•½ì ì„ ìœ ë°œí•˜ëŠ” ì½”ë“œ(sink:zend_execute_API.c:221)ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.
```
static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) {
	va_list va;
	char *message = NULL;

	va_start(va, format);
	zend_vspprintf(&message, 0, format, va);

	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
		zend_throw_error(exception_ce, message);
}
```
ì´ ì½”ë“œì—ì„œ Ksign ìŠ¬ë¼ì´ì„œ ë„êµ¬ê°€ ì¶”ì¶œí–ˆì–´ì•¼ í•˜ëŠ” ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì§ì ‘ ì‘ì„±í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

zend_throw_error(exception_cs, message) ì´ ë¶€ë¶„ì´ ì¤‘ê°„ ë‹¨ê³„ì¸ ê²ƒìœ¼ë¡œ ì˜ì‹¬ë¨.



<?php $name="%n%n%n"; $name::doSomething(); ?>
ì°¸ê³ : https://bugs.php.net/bug.php?id=71105
```
zend_class_entry *zend_fetch_class(zend_string *class_name, int fetch_type) /* {{{ */
{
	zend_class_entry *ce;
	int fetch_sub_type = fetch_type & ZEND_FETCH_CLASS_MASK;
check_fetch_type:
	if (fetch_type & ZEND_FETCH_CLASS_NO_AUTOLOAD) {
	} else if ((ce = zend_lookup_class_ex(class_name, NULL, 1)) == NULL) {
		if (!(fetch_type & ZEND_FETCH_CLASS_SILENT) && !EG(exception)) {
			if (fetch_sub_type == ZEND_FETCH_CLASS_INTERFACE) {
			} else if (fetch_sub_type == ZEND_FETCH_CLASS_TRAIT) {
			} else {
				zend_throw_or_error(fetch_type, NULL, "Class '%s' not found", ZSTR_VAL(class_name));
			}
		}
		return NULL;
	}
	return ce;
}
/* }}} */

zend_class_entry *zend_fetch_class_by_name(zend_string *class_name, const zval *key, int fetch_type) /* {{{ */
{
	zend_class_entry *ce;
	if (fetch_type & ZEND_FETCH_CLASS_NO_AUTOLOAD) {
	} else if ((ce = zend_lookup_class_ex(class_name, key, 1)) == NULL) {
		if ((fetch_type & ZEND_FETCH_CLASS_SILENT) == 0 && !EG(exception)) {
			if ((fetch_type & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_INTERFACE) {
			} else if ((fetch_type & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_TRAIT) {
			} else {
				zend_throw_or_error(fetch_type, NULL, "Class '%s' not found", ZSTR_VAL(class_name));
}

static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) {
	va_list va;
	char *message = NULL;

	va_start(va, format);
	zend_vspprintf(&message, 0, format, va);

	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
		zend_throw_error(exception_ce, message);
}

/* Zend/zend.c:1313 */
ZEND_API ZEND_COLD void zend_throw_error(zend_class_entry *exception_ce, const char *format, ...) /* {{{ */
{
	va_list va;
	char *message = NULL;
	
	if (exception_ce) {
		if (!instanceof_function(exception_ce, zend_ce_error)) {
			zend_error(E_NOTICE, "Error exceptions must be derived from Error");
			exception_ce = zend_ce_error;
		}
	} else {
		exception_ce = zend_ce_error;
	}

	va_start(va, format);
	zend_vspprintf(&message, 0, format, va);

/* Zend/zend.c:632 */
int zend_startup(zend_utility_functions *utility_functions, char **extensions) /* {{{ */
{
#ifdef ZTS
	zend_compiler_globals *compiler_globals;
	zend_executor_globals *executor_globals;
	extern ZEND_API ts_rsrc_id ini_scanner_globals_id;
	extern ZEND_API ts_rsrc_id language_scanner_globals_id;
	ZEND_TSRMLS_CACHE_UPDATE();
#else
	extern zend_ini_scanner_globals ini_scanner_globals;
	extern zend_php_scanner_globals language_scanner_globals;
#endif

	start_memory_manager();

	virtual_cwd_startup(); /* Could use shutdown to free the main cwd but it would just slow it down for CGI */

#if defined(__FreeBSD__) || defined(__DragonFly__)
	/* FreeBSD and DragonFly floating point precision fix */
	fpsetmask(0);
#endif

	zend_startup_strtod();
	zend_startup_extensions_mechanism();

	/* Set up utility functions and values */
	zend_error_cb = utility_functions->error_function;
	zend_printf = utility_functions->printf_function;
	zend_write = (zend_write_func_t) utility_functions->write_function;
	zend_fopen = utility_functions->fopen_function;
	if (!zend_fopen) {
		zend_fopen = zend_fopen_wrapper;
	}
	zend_stream_open_function = utility_functions->stream_open_function;
	zend_message_dispatcher_p = utility_functions->message_handler;
#ifndef ZEND_SIGNALS
	zend_block_interruptions = utility_functions->block_interruptions;
	zend_unblock_interruptions = utility_functions->unblock_interruptions;
#endif
	zend_get_configuration_directive_p = utility_functions->get_configuration_directive;
	zend_ticks_function = utility_functions->ticks_function;
	zend_on_timeout = utility_functions->on_timeout;
	zend_vspprintf = utility_functions->vspprintf_function;

/* main/main.c:2058 */
int php_module_startup(sapi_module_struct *sf, zend_module_entry *additional_modules, uint num_additional_modules)
{
	zend_utility_functions zuf;
    zuf.vspprintf_function = vspprintf;
	zuf.vstrpprintf_function = vstrpprintf;
	zuf.getenv_function = sapi_getenv;
	zuf.resolve_path_function = php_resolve_path_for_zend;
	zend_startup(&zuf, NULL);


/* main/spprintf.c:744 */

	while (*fmt) {
		if (*fmt != '%') {
			INS_CHAR(xbuf, *fmt, is_char);
		} else {
			/*
			 * Default variable settings
			 */
			adjust = RIGHT;
			alternate_form = print_sign = print_blank = NO;
			pad_char = ' ';
			prefix_char = NUL;
			free_zcopy = 0;

			fmt++;

			/*
			 * Try to avoid checking for flags, width or precision
			 */
			if (isascii((int)*fmt) && !islower((int)*fmt)) {
				/*
				 * Recognize flags: -, #, BLANK, +
				 */
				for (;; fmt++) {
					if (*fmt == '-')
						adjust = LEFT;
					else if (*fmt == '+')
						print_sign = YES;
					else if (*fmt == '#')
						alternate_form = YES;
					else if (*fmt == ' ')
						print_blank = YES;
					else if (*fmt == '0')
						pad_char = '0';
					else
						break;
				}

				/*
				 * Check if a width was specified
				 */
				if (isdigit((int)*fmt)) {
					STR_TO_DEC(fmt, min_width);
					adjust_width = YES;
				} else if (*fmt == '*') {
					min_width = va_arg(ap, int);
					fmt++;
					adjust_width = YES;
					if (min_width < 0) {
						adjust = LEFT;
						min_width = -min_width;
					}
				} else
					adjust_width = NO;

				/*
				 * Check if a precision was specified
				 */
				if (*fmt == '.') {
					adjust_precision = YES;
					fmt++;
					if (isdigit((int)*fmt)) {
						STR_TO_DEC(fmt, precision);
					} else if (*fmt == '*') {
						precision = va_arg(ap, int);
						fmt++;
						if (precision < 0)
							precision = 0;
					} else
						precision = 0;

					if (precision > FORMAT_CONV_MAX_PRECISION) {
						precision = FORMAT_CONV_MAX_PRECISION;
					}
				} else
					adjust_precision = NO;
			} else
				adjust_precision = adjust_width = NO;

			/*
			 * Modifier check
			 */
            switch (*fmt) {
                ...
				case 'n':
					*(va_arg(ap, int *)) = is_char? (int)((smart_string *)xbuf)->len : (int)ZSTR_LEN(((smart_str *)xbuf)->s);
```
[
    {
        "FileName": "manager.c",
        "Caller": "add_server",
        "Source": false,
        "Sink": true,
        "idx": 0,
        "CWE-ID": "CWE-78",
        "category": "CallExpression",
        "criterion": "system",
        "line": 42,
        "label": -3,
        "slices": [
            "int main(int argc, char **argv)\n",
            "{\n",
            "    int sfd;\n",
            "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
            "        struct sockaddr_un svaddr;\n",
            "        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);\n",
            "        if (sfd == -1) {\n",
            "        setnonblocking(sfd);\n",
            "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
            "    } \n",
            "    manager.fd = sfd;\n",
            "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
            "}\n",
            "static void manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
            "{\n",
            "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
            "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
            "    if (r == -1) {\n",
            "    if (r > BUF_SIZE / 2) {\n",
            "    char *action = get_action(buf, r);\n",
            "    if (action == NULL) {\n",
            "    if (strcmp(action, \"add\") == 0) {\n",
            "        struct server *server = get_server(buf, r);\n",
            "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
            "        int ret = add_server(manager, server);\n",
            "}\n",
            "static int add_server(struct manager_ctx *manager, struct server *server)\n",
            "{\n",
            "    int ret = check_port(manager, server);\n",
            "    cork_hash_table_put(server_table, (void *)server->port, (void *)server, &new, NULL, NULL);\n",
            "    char *cmd = construct_command_line(manager, server);\n",
            "    construct_command_line(struct manager_ctx *manager, struct server *server){\n",
            "        static char cmd[BUF_SIZE];\n",
            "        char *method = manager->method;\n",
            "        int i;\n",
            "        build_config(working_dir, server);\n",
            "        if (server->method) method = server->method;\n",
            "        memset(cmd, 0, BUF_SIZE);\n",
            "        snprintf(cmd, BUF_SIZE,\n",
            "                \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n",
            "                executable, method, manager->manager_address,\n",
            "                working_dir, server->port, working_dir, server->port);\n",
            "        return cmd;\n",
            "    }\n",
            "    if (system(cmd) == -1) {\n",
            "}\n"
        ]
    }
]
```

ì´ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ Ksign ëª¨ë¸ì— ì ìš©í•´ì„œ ê²°ê³¼ë¥¼ íƒì§€í•´ë³´ì•˜ë”ë‹ˆ ì •ìƒìœ¼ë¡œ ì˜ˆì¸¡í–ˆë‹¤.

---

#### SARDëŠ” ì˜ íƒì§€í•˜ëŠ”ë° ì´ CVEëŠ” íƒì§€ ëª»í–ˆë˜ ì´ìœ 

1. **ë¶€ì ì ˆí•œ criterion**
   * ì´ ì·¨ì•½ì ì˜ ê²½ìš° criterionìœ¼ë¡œ `zend_throw_error`ê°€ ì¡íˆì§€ ì•Šì•„ ì •ìƒìœ¼ë¡œ íŒë‹¨ëœ ê²ƒìœ¼ë¡œ ë³´ì„.

---

## ì·¨ì•½ì  ì„¸ë¶€ ì‚¬í•­

### â—ï¸ì·¨ì•½ ì½”ë“œ

#### Sink: `before_zend_execute_API.c:221`

```c
zend_throw_error(exception_ce, message);
```

**ë¬¸ì œì **:
* `message`ëŠ” ì™¸ë¶€ ì…ë ¥ì„ í¬í•¨í•œ í¬ë§· ë¬¸ìì—´ë¡œ `zend_vspprintf()`ì—ì„œ ìƒì„±ë¨
* ì´ ë¬¸ìì—´ì´ í¬ë§· ë¬¸ìì—´ë¡œ ê·¸ëŒ€ë¡œ í•´ì„ë˜ì–´ CWE-134 ì·¨ì•½ì  ë°œìƒ ê°€ëŠ¥

### âœ… ê°œì„  ì½”ë“œ

**íŒ¨ì¹˜ ìœ„ì¹˜**: `after_zend_execute_API.c:221`

```c
zend_throw_error(exception_ce, "%s", message);
```

**ê°œì„  ë°©ë²•**:

* ì™¸ë¶€ ì…ë ¥ì´ í¬í•¨ëœ ë¬¸ìì—´ì„ í¬ë§· ë¬¸ìì—´ë¡œ ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šê³ , ê³ ì •ëœ `"%s"`ë¥¼ ì‚¬ìš©í•´ ì•ˆì „í•˜ê²Œ ì¶œë ¥í•¨
* ì´ë¡œì¨ í¬ë§· ë¬¸ìì—´ ì·¨ì•½ì (CWE-134) ë°œìƒ ê°€ëŠ¥ì„± ì œê±°

---

## íƒì§€ ê²°ê³¼
\* cve ì„¤ëª…ì— ë‚˜ì˜¨ ì·¨ì•½í•œ í•¨ìˆ˜(Caller)ì— ëŒ€í•œ ìŠ¬ë¼ì´ìŠ¤ ê´€ë ¨ ë°ì´í„°ë§Œ ì¶”ì¶œ
* ì—†ìŒ